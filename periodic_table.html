<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>周期表テトリス v3（空欄=原子番号・欠番非表示・iPad対応）</title>
<style>
  :root {
    --bg: #0f172a;
    --panel: #111827;
    --grid: #1f2937;
    --text: #e5e7eb;
    --accent: #22d3ee;
    --ok: #34d399;
    --bad: #f87171;
    --cell-gap: 2px;
    --cell-size: 38px; /* JSで上書きして画面幅いっぱいに */
  }
  * { box-sizing: border-box; }
  body {
    margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN",
    "Noto Sans JP", "Yu Gothic UI", "Yu Gothic", Meiryo, sans-serif;
    background: radial-gradient(1200px 800px at 70% 10%, #111827 0%, #0b1222 35%, #0f172a 70%);
    color: var(--text); display: grid; place-items: start center; min-height: 100dvh; padding: 16px;
  }
  .app { width: 100%; max-width: 1200px; display: grid; grid-template-columns: 1fr 320px; gap: 16px; }
  @media (max-width: 980px) { .app { grid-template-columns: 1fr; } }

  .board-wrap { width: 100%; background: color-mix(in oklab, var(--panel) 80%, black 20%);
    padding: 12px; border: 1px solid #334155; border-radius: 16px; position: relative;
    box-shadow: 0 10px 40px rgba(0,0,0,.35); }
  .board { width: 100%; display: grid; grid-template-columns: repeat(18, var(--cell-size));
    grid-template-rows: repeat(7, var(--cell-size)); gap: var(--cell-gap); position: relative; }
  .cell { width: var(--cell-size); height: var(--cell-size); background: var(--grid);
    border-radius: 8px; display: grid; place-items: center; font-weight: 800; font-size: 14px; color: #cbd5e1;
    position: relative; overflow: hidden; user-select: none; touch-action: manipulation; }
  .cell .z { font-size: clamp(11px, calc(var(--cell-size)*0.32), 16px); opacity: .65; font-weight: 700; }
  .cell.filled { background: #0e3b2d; }

  .falling { position: absolute; transform: translate(-50%, -50%); width: var(--cell-size); height: var(--cell-size);
    background: #1f2937; border: 2px solid var(--accent); border-radius: 8px; display: grid; place-items: center;
    text-align: center; pointer-events: none; box-shadow: 0 10px 30px rgba(0,0,0,.45); }
  .falling .wrap { display: grid; gap: 2px; }
  .falling .sym { font-weight: 900; letter-spacing: .5px; font-size: clamp(12px, calc(var(--cell-size)*0.42), 28px); }
  .falling .jp { font-size: clamp(9px, calc(var(--cell-size)*0.26), 16px); opacity: .9; }

  .hud { background: color-mix(in oklab, var(--panel) 85%, black 15%); border: 1px solid #334155;
    border-radius: 16px; padding: 14px; position: sticky; top: 16px; box-shadow: 0 10px 40px rgba(0,0,0,.35); }
  .hud h1 { font-size: 18px; margin: 0 0 10px; }
  .row { display: flex; gap: 8px; align-items: center; margin: 6px 0; flex-wrap: wrap; }
  .tag { padding: 2px 8px; border-radius: 999px; background: #0b1222; border: 1px solid #1f2937; font-size: 12px; }
  .btn { display: inline-flex; align-items: center; gap: 6px; padding: 8px 10px; border-radius: 10px; background: #0b1222;
    border: 1px solid #334155; color: var(--text); cursor: pointer; user-select: none; transition: .15s transform ease, .15s background ease, .15s border-color ease; }
  .btn:hover { transform: translateY(-1px); background: #0f1a30; border-color: #3b82f6; }
  .btn.primary { background: #13213f; border-color: #3b82f6; }
  .stats { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 10px; }
  .card { background: #0b1222; border: 1px solid #1f2937; border-radius: 12px; padding: 10px; font-size: 14px; }
  .big { font-size: 20px; font-weight: 800; }
  .help { font-size: 12px; opacity: .85; line-height: 1.5; }
  .toast { position: fixed; top: 10px; left: 50%; transform: translateX(-50%); background: #102b1f; border: 1px solid #22c55e; color: #d1fae5;
    padding: 8px 12px; border-radius: 10px; box-shadow: 0 8px 30px rgba(0,0,0,.3); font-size: 13px; opacity: 0; pointer-events: none; transition: .2s opacity ease; }
  .toast.show { opacity: 1; }
</style>
</head>
<body>
<div class="app">
  <div class="board-wrap" id="boardWrap">
    <div id="board" class="board" aria-label="periodic-board"></div>
    <div id="falling" class="falling" style="display:none">
      <div class="wrap">
        <div class="sym">He</div>
        <div class="jp">ヘリウム</div>
      </div>
    </div>
  </div>

  <aside class="hud" aria-label="hud">
    <h1>周期表テトリス v3</h1>
    <div class="row">
      <button id="restart" class="btn primary">↻ リスタート（Enter）</button>
      <button id="toggleMode" class="btn">モード切替 (M)</button>
      <span id="modeTag" class="tag">全範囲</span>
    </div>
    <div class="stats">
      <div class="card">スコア<br><span id="score" class="big">0</span></div>
      <div class="card">コンボ<br><span id="combo" class="big">0</span></div>
      <div class="card">ミス<br><span id="miss" class="big">0/5</span></div>
      <div class="card">配置済み<br><span id="placed" class="big">0</span></div>
      <div class="card">タイム<br><span id="time" class="big">0.0s</span></div>
    </div>
    <div class="card" style="margin-top:10px">
      出題モード：
      <ul style="margin:.4em 0 .2em .9em; padding:0; font-size:12px; line-height:1.6">
        <li><b>全範囲</b>＝Z1〜36 ＋ 1/2/17/18族（周期7まで）</li>
        <li><b>族集中</b>＝1/2/17/18族のみ</li>
        <li><b>1〜20</b>＝Z1〜20のみ</li>
      </ul>
      <div class="help">iPad：左右スワイプ＝左右移動／下スワイプ＝ハードドロップ／タップ＝少し加速</div>
    </div>
  </aside>
</div>
<div id="toast" class="toast">Great!</div>

<script>
/** ===================== 元素データ =====================
 * 対象：
 *  - Z=1..36（H〜Kr）すべて
 *  - 1/2/17/18族は周期7まで全員（Rb, Sr, Cs, Ba, Fr, Ra / I, At, Ts / Xe, Rn, Og など）
 */
const BASE_SET_1to36 = [
  [1,"H","水素","Hydrogen",1,1], [2,"He","ヘリウム","Helium",1,18],
  [3,"Li","リチウム","Lithium",2,1], [4,"Be","ベリリウム","Beryllium",2,2],
  [5,"B","ホウ素","Boron",2,13], [6,"C","炭素","Carbon",2,14],
  [7,"N","窒素","Nitrogen",2,15], [8,"O","酸素","Oxygen",2,16],
  [9,"F","フッ素","Fluorine",2,17], [10,"Ne","ネオン","Neon",2,18],
  [11,"Na","ナトリウム","Sodium",3,1], [12,"Mg","マグネシウム","Magnesium",3,2],
  [13,"Al","アルミニウム","Aluminium",3,13], [14,"Si","ケイ素","Silicon",3,14],
  [15,"P","リン","Phosphorus",3,15], [16,"S","硫黄","Sulfur",3,16],
  [17,"Cl","塩素","Chlorine",3,17], [18,"Ar","アルゴン","Argon",3,18],
  [19,"K","カリウム","Potassium",4,1], [20,"Ca","カルシウム","Calcium",4,2],
  [21,"Sc","スカンジウム","Scandium",4,3], [22,"Ti","チタン","Titanium",4,4],
  [23,"V","バナジウム","Vanadium",4,5], [24,"Cr","クロム","Chromium",4,6],
  [25,"Mn","マンガン","Manganese",4,7], [26,"Fe","鉄","Iron",4,8],
  [27,"Co","コバルト","Cobalt",4,9], [28,"Ni","ニッケル","Nickel",4,10],
  [29,"Cu","銅","Copper",4,11], [30,"Zn","亜鉛","Zinc",4,12],
  [31,"Ga","ガリウム","Gallium",4,13], [32,"Ge","ゲルマニウム","Germanium",4,14],
  [33,"As","ヒ素","Arsenic",4,15], [34,"Se","セレン","Selenium",4,16],
  [35,"Br","臭素","Bromine",4,17], [36,"Kr","クリプトン","Krypton",4,18]
];
const GROUPS_EXTRA = [
  [37,"Rb","ルビジウム","Rubidium",5,1], [55,"Cs","セシウム","Cesium",6,1], [87,"Fr","フランシウム","Francium",7,1],
  [38,"Sr","ストロンチウム","Strontium",5,2], [56,"Ba","バリウム","Barium",6,2], [88,"Ra","ラジウム","Radium",7,2],
  [53,"I","ヨウ素","Iodine",5,17], [85,"At","アスタチン","Astatine",6,17], [117,"Ts","テネシン","Tennessine",7,17],
  [54,"Xe","キセノン","Xenon",5,18], [86,"Rn","ラドン","Radon",6,18], [118,"Og","オガネソン","Oganesson",7,18]
];
const ELEMENTS_ALL = [...BASE_SET_1to36, ...GROUPS_EXTRA]
  .map(([z,sym,jp,en,period,group])=>({z,sym,jp,en,period,group}))
  .sort((a,b)=>a.z-b.z);

// period=1..7, group=1..18 に対し、実在するセルのみ生成
const ROWS = 7, COLS = 18;
const cellByKey = new Map(); // key: `${r}-${c}` => {el, filled, elem}

// ===== DOM =====
const boardWrap = document.getElementById('boardWrap');
const boardEl = document.getElementById('board');
const fallingEl = document.getElementById('falling');
const scoreEl = document.getElementById('score');
const comboEl = document.getElementById('combo');
const missEl = document.getElementById('miss');
const placedEl = document.getElementById('placed');
const modeTag = document.getElementById('modeTag');
const timeEl = document.getElementById('time');
const toastEl = document.getElementById('toast');

// ===== オーディオ（効果音：正解/不正解） =====
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
function ensureAudio(){ if (!audioCtx) audioCtx = new AudioCtx(); }
function beep(type='ok'){
  ensureAudio();
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = 'sine';
  if (type==='ok'){ o.frequency.value = 880; } else { o.frequency.value = 220; }
  g.gain.setValueAtTime(0.0001, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.2, audioCtx.currentTime + 0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.18);
  o.connect(g).connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime + 0.2);
}

// ===== グリッド生成（実在セルのみ） =====
function buildGrid(){
  boardEl.innerHTML = '';
  cellByKey.clear();
  for (const e of ELEMENTS_ALL){
    const key = `${e.period}-${e.group}`;
    if (cellByKey.has(key)) continue; // 念のため
    const cell = document.createElement('div');
    cell.className = 'cell';
    cell.style.gridRowStart = e.period;
    cell.style.gridColumnStart = e.group;
    // 初期表示は原子番号（未配置感を出す）
    cell.innerHTML = `<div class="z">${e.z}</div>`;
    boardEl.appendChild(cell);
    cellByKey.set(key, {el:cell, filled:false, elem:e});
  }
}
buildGrid();

// ===== レイアウト：画面幅いっぱいにセルを自動調整 =====
function updateCellSize(){
  const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-gap'));
  const wrapW = boardWrap.clientWidth - 24; // 内側余白の目安
  const size = Math.max(22, Math.floor((wrapW - (COLS-1)*gap) / COLS));
  document.documentElement.style.setProperty('--cell-size', size + 'px');
}
window.addEventListener('resize', updateCellSize); updateCellSize();

// ===== 状態 =====
const MODE_ALL = 0, MODE_FOCUS = 1, MODE_1to20 = 2;
let mode = MODE_ALL;
let score=0, combo=0, misses=0, placed=0;
let active=null; let timer=null; let paused=false;
const BASE_SPEED=900; let speed=BASE_SPEED; const MAX_MISS=5;
const placedSet = new Set();
let startTimeMs = 0; // クリア時間計測
let timeTimer = null;

const TARGET_SET_ALL = new Set(ELEMENTS_ALL.map(e=>e.z));
const TARGET_SET_FOCUS = new Set(ELEMENTS_ALL.filter(e=>[1,2,17,18].includes(e.group)).map(e=>e.z));
const TARGET_SET_1to20 = new Set(ELEMENTS_ALL.filter(e=>e.z<=20).map(e=>e.z));

function showToast(msg){ toastEl.textContent = msg; toastEl.classList.add('show'); setTimeout(()=>toastEl.classList.remove('show'), 900); }
function randChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

function currentPool(){
  let base;
  if (mode===MODE_ALL){ base = ELEMENTS_ALL; }
  else if (mode===MODE_FOCUS){ base = ELEMENTS_ALL.filter(e=>[1,2,17,18].includes(e.group)); }
  else { base = ELEMENTS_ALL.filter(e=>e.z<=20); }
  return base.filter(e=>!placedSet.has(e.z));
}

function currentTargetSet(){
  if (mode===MODE_ALL) return TARGET_SET_ALL;
  if (mode===MODE_FOCUS) return TARGET_SET_FOCUS;
  return TARGET_SET_1to20;
}

function spawn(){
  const p = currentPool();
  if (p.length === 0){ gameClear(); return; }
  const e = randChoice(p);
  // 初期位置：中央上部（列=9固定、y=0）
  active = { ...e, x: 9, y: 0 };
  fallingEl.querySelector('.sym').textContent = `${e.sym}`;
  fallingEl.querySelector('.jp').textContent = `${e.jp}`;
  fallingEl.style.display = 'grid';
  renderActive();
}

function renderActive(){
  if (!active) return;
  const size = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size'));
  const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-gap'));
  const cw = size + gap, ch = size + gap;
  const centerX = (active.x-1)*cw + size/2 + gap;
  const targetY = (active.period-1)*ch + size/2 + gap;
  const clampedY = Math.min(active.y, targetY);
  fallingEl.style.left = `${centerX}px`;
  fallingEl.style.top = `${clampedY}px`;
}

function step(){
  if (paused || !active) return;
  const size = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size'));
  const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-gap'));
  const ch = size + gap; const targetY = (active.period-1)*ch + size/2 + gap;
  active.y += Math.max(2, ch/8);
  if (active.y >= targetY - 1){ const ok = (active.x === active.group); place(ok); return; }
  renderActive();
}

function place(ok){
  const key = `${active.period}-${active.group}`;
  const cell = cellByKey.get(key);
  if (cell){
    cell.filled = true; cell.el.classList.add('filled');
    cell.el.textContent = `${active.sym} ${active.jp}`;
  }
  placedSet.add(active.z);

  if (ok){ const add = 100 + combo*20; score += add; combo += 1; placed += 1; beep('ok'); showToast(`正解！ +${add}`); }
  else { misses += 1; combo = 0; beep('ng'); showToast(`ミス！ 正解は [${active.period},${active.group}]`); }

  updateHUD();
  fallingEl.style.display = 'none'; active = null;

  const targetSet = currentTargetSet();
  let done = true; for (const z of targetSet){ if (!placedSet.has(z)) { done = false; break; } }
  if (done) { gameClear(); return; }
  if (misses >= MAX_MISS){ gameOver(); return; }
  spawn();
}

function updateHUD(){
  scoreEl.textContent = score; comboEl.textContent = combo; missEl.textContent = `${misses}/${MAX_MISS}`; placedEl.textContent = placed;
  if (startTimeMs){ const t = (performance.now() - startTimeMs)/1000; timeEl.textContent = `${t.toFixed(1)}s`; }
}

function clearBoard(){
  placedSet.clear();
  for (const [key, cell] of cellByKey){
    cell.filled = false; cell.el.className = 'cell'; cell.el.innerHTML = `<div class="z">${cell.elem.z}</div>`;
  }
}

function loop(){ step(); }

function start(reset=false){
  if (reset){ score=0; combo=0; misses=0; placed=0; clearBoard(); }
  updateHUD(); paused=false; if (timer) clearInterval(timer); timer = setInterval(loop, 900);
  startTimeMs = performance.now(); if (timeTimer) clearInterval(timeTimer);
  timeTimer = setInterval(updateHUD, 100);
  if (!active) spawn();
}

function togglePause(){ if (!timer) return; paused = !paused; showToast(paused? '一時停止' : '再開'); }
function toggleMode(){
  mode = (mode + 1) % 3;
  modeTag.textContent = mode===0 ? '全範囲' : (mode===1 ? '族集中 (1/2/17/18)' : '1〜20');
  showToast(modeTag.textContent);
  // モード切替で再スタート
  start(true);
}

function gameOver(){
  clearInterval(timer); timer=null; active=null; if (timeTimer) { clearInterval(timeTimer); timeTimer=null; }
  showToast(`ゲームオーバー！ スコア:${score}`);
}

function gameClear(){
  clearInterval(timer); timer=null; active=null; if (timeTimer) { clearInterval(timeTimer); timeTimer=null; }
  const secs = (performance.now() - startTimeMs)/1000;
  const bonus = Math.max(0, Math.round(30000 / (secs + 10))); // 速いほど高ボーナス（上限≈3000）
  score += bonus; updateHUD();
  showToast(`クリア！ ${secs.toFixed(1)}s / タイムボーナス +${bonus}`);
}

// ===== 入力（キーボード） =====
function tickFastOnce(){ if (!active) return; const size = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size')); const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-gap')); const ch = size + gap; active.y += ch * .6; step(); }
function hardDrop(){ if (!active) return; const size = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size')); const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-gap')); const ch = size + gap; const targetY = (active.period-1)*ch + size/2 + gap; active.y = targetY; step(); }

document.addEventListener('keydown', (e)=>{
  if (!active && e.key === 'Enter'){ start(true); return; }
  if (e.key === 'Enter'){ start(true); return; }
  if (e.key.toLowerCase() === 'p'){ togglePause(); return; }
  if (e.key.toLowerCase() === 'm'){ toggleMode(); return; }
  if (!active) return;
  if (e.key === 'ArrowLeft'){ active.x = Math.max(1, active.x-1); renderActive(); }
  else if (e.key === 'ArrowRight'){ active.x = Math.min(COLS, active.x+1); renderActive(); }
  else if (e.key === 'ArrowDown'){ tickFastOnce(); }
  else if (e.code === 'Space'){ hardDrop(); }
  e.preventDefault();
});

// ===== タッチ操作（iPad） =====
let touchStartX=0, touchStartY=0, touchMoved=false;
const SWIPE_THRESHOLD = 24; // px
boardWrap.addEventListener('touchstart', (ev)=>{
  const t = ev.changedTouches[0]; touchStartX = t.clientX; touchStartY = t.clientY; touchMoved = false; ensureAudio();
}, {passive:true});
boardWrap.addEventListener('touchmove', (ev)=>{
  if (!active) return;
  const t = ev.changedTouches[0]; const dx = t.clientX - touchStartX; const dy = t.clientY - touchStartY;
  if (Math.abs(dx) > Math.abs(dy)){
    if (Math.abs(dx) > SWIPE_THRESHOLD){ if (dx > 0){ active.x = Math.min(COLS, active.x+1); } else { active.x = Math.max(1, active.x-1); } renderActive(); touchStartX = t.clientX; touchStartY = t.clientY; touchMoved = true; }
  } else {
    if (dy > SWIPE_THRESHOLD){ hardDrop(); touchMoved = true; }
  }
}, {passive:true});
boardWrap.addEventListener('touchend', ()=>{ if (!active) return; if (!touchMoved){ tickFastOnce(); } });

// ===== ボタン =====
const $ = (sel)=>document.querySelector(sel);
$('#restart').addEventListener('click', ()=>start(true));
$('#toggleMode').addEventListener('click', toggleMode);

// 自動開始
start(true);
</script>
</body>
</html>
