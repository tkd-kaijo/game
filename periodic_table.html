<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>周期表テトリス v2（1〜36＋1/2/17/18族 全範囲、iPad対応）</title>
<style>
  :root {
    --bg: #0f172a;
    --panel: #111827;
    --grid: #1f2937;
    --text: #e5e7eb;
    --accent: #22d3ee;
    --ok: #34d399;
    --bad: #f87171;
    --ghost: #374151;
    --cell-gap: 2px;
    --cell-size: 38px; /* JSで上書きして画面幅いっぱいに */
  }
  * { box-sizing: border-box; }
  body {
    margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN",
    "Noto Sans JP", "Yu Gothic UI", "Yu Gothic", Meiryo, sans-serif;
    background: radial-gradient(1200px 800px at 70% 10%, #111827 0%, #0b1222 35%, #0f172a 70%);
    color: var(--text); display: grid; place-items: start center; min-height: 100dvh; padding: 16px;
  }
  .app { width: 100%; max-width: 1200px; display: grid; grid-template-columns: 1fr 320px; gap: 16px; }
  @media (max-width: 980px) { .app { grid-template-columns: 1fr; } }

  .board-wrap { width: 100%; background: color-mix(in oklab, var(--panel) 80%, black 20%);
    padding: 12px; border: 1px solid #334155; border-radius: 16px; position: relative;
    box-shadow: 0 10px 40px rgba(0,0,0,.35); }
  .board { width: 100%; display: grid; grid-template-columns: repeat(18, var(--cell-size));
    grid-template-rows: repeat(7, var(--cell-size)); gap: var(--cell-gap); position: relative; }
  .cell { width: var(--cell-size); height: var(--cell-size); background: var(--grid);
    border-radius: 8px; display: grid; place-items: center; font-weight: 700; font-size: 13px; color: #cbd5e1;
    position: relative; overflow: hidden; user-select: none; touch-action: manipulation; }
  .cell.invalid { background: #0b1222; opacity: .35 }
  .cell.filled { background: #0e3b2d; }
  .cell .small { position: absolute; bottom: 2px; right: 6px; font-size: 10px; opacity: .6; font-weight: 500; }

  .falling { position: absolute; transform: translate(-50%, -50%); width: var(--cell-size); height: var(--cell-size);
    background: #1f2937; border: 2px solid var(--accent); border-radius: 8px; display: grid; place-items: center;
    text-align: center; pointer-events: none; box-shadow: 0 10px 30px rgba(0,0,0,.45); }
  .falling .wrap { display: grid; gap: 2px; }
  .falling .sym { font-weight: 900; letter-spacing: .5px; font-size: clamp(12px, calc(var(--cell-size)*0.42), 28px); }
  .falling .jp { font-size: clamp(9px, calc(var(--cell-size)*0.26), 16px); opacity: .9; }

  .hud { background: color-mix(in oklab, var(--panel) 85%, black 15%); border: 1px solid #334155;
    border-radius: 16px; padding: 14px; position: sticky; top: 16px; box-shadow: 0 10px 40px rgba(0,0,0,.35); }
  .hud h1 { font-size: 18px; margin: 0 0 10px; }
  .row { display: flex; gap: 8px; align-items: center; margin: 6px 0; flex-wrap: wrap; }
  .tag { padding: 2px 8px; border-radius: 999px; background: #0b1222; border: 1px solid #1f2937; font-size: 12px; }
  .btn { display: inline-flex; align-items: center; gap: 6px; padding: 8px 10px; border-radius: 10px; background: #0b1222;
    border: 1px solid #334155; color: var(--text); cursor: pointer; user-select: none; transition: .15s transform ease, .15s background ease, .15s border-color ease; }
  .btn:hover { transform: translateY(-1px); background: #0f1a30; border-color: #3b82f6; }
  .btn.primary { background: #13213f; border-color: #3b82f6; }
  .stats { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 10px; }
  .card { background: #0b1222; border: 1px solid #1f2937; border-radius: 12px; padding: 10px; font-size: 14px; }
  .big { font-size: 20px; font-weight: 800; }
  .help { font-size: 12px; opacity: .85; line-height: 1.5; }
  .toast { position: fixed; top: 10px; left: 50%; transform: translateX(-50%); background: #102b1f; border: 1px solid #22c55e; color: #d1fae5;
    padding: 8px 12px; border-radius: 10px; box-shadow: 0 8px 30px rgba(0,0,0,.3); font-size: 13px; opacity: 0; pointer-events: none; transition: .2s opacity ease; }
  .toast.show { opacity: 1; }
</style>
</head>
<body>
<div class="app">
  <div class="board-wrap" id="boardWrap">
    <div id="board" class="board" aria-label="periodic-board"></div>
    <div id="falling" class="falling" style="display:none">
      <div class="wrap">
        <div class="sym">He</div>
        <div class="jp">ヘリウム</div>
      </div>
    </div>
  </div>

  <aside class="hud" aria-label="hud">
    <h1>周期表テトリス v2</h1>
    <div class="row">
      <button id="restart" class="btn primary">↻ リスタート（Enter）</button>
      <button id="toggleMode" class="btn">M: モード切替</button>
      <span id="modeTag" class="tag">全範囲</span>
    </div>
    <div class="stats">
      <div class="card">スコア<br><span id="score" class="big">0</span></div>
      <div class="card">コンボ<br><span id="combo" class="big">0</span></div>
      <div class="card">ミス<br><span id="miss" class="big">0/5</span></div>
      <div class="card">配置済み<br><span id="placed" class="big">0</span></div>
    </div>
    <div class="card" style="margin-top:10px">
      出題モード：<br>
      <div class="help">全範囲＝<b>Z1〜36</b> ＋ <b>1,2,17,18族の全元素</b>／ 族集中＝<b>1,2,17,18族のみ</b></div>
    </div>
    <div class="card" style="margin-top:10px">
      <div class="help">
        操作：← → 移動／↓ 加速／Space ハードドロップ／P 一時停止／M モード切替／Enter リスタート<br>
        iPad：<b>左右スワイプ</b>＝左右移動、<b>下スワイプ</b>＝ハードドロップ、<b>タップ</b>＝少し加速
      </div>
    </div>
  </aside>
</div>
<div id="toast" class="toast">Great!</div>

<script>
/** ===================== 元素データ =====================
 * 対象：
 *  - Z=1..36（H〜Kr）すべて
 *  - 1/2/17/18族は周期7まで全員（Rb, Sr, Cs, Ba, Fr, Ra / I, At, Ts / Xe, Rn, Og など）
 */
const BASE_SET_1to36 = [
  [1,"H","水素","Hydrogen",1,1], [2,"He","ヘリウム","Helium",1,18],
  [3,"Li","リチウム","Lithium",2,1], [4,"Be","ベリリウム","Beryllium",2,2],
  [5,"B","ホウ素","Boron",2,13], [6,"C","炭素","Carbon",2,14],
  [7,"N","窒素","Nitrogen",2,15], [8,"O","酸素","Oxygen",2,16],
  [9,"F","フッ素","Fluorine",2,17], [10,"Ne","ネオン","Neon",2,18],
  [11,"Na","ナトリウム","Sodium",3,1], [12,"Mg","マグネシウム","Magnesium",3,2],
  [13,"Al","アルミニウム","Aluminium",3,13], [14,"Si","ケイ素","Silicon",3,14],
  [15,"P","リン","Phosphorus",3,15], [16,"S","硫黄","Sulfur",3,16],
  [17,"Cl","塩素","Chlorine",3,17], [18,"Ar","アルゴン","Argon",3,18],
  [19,"K","カリウム","Potassium",4,1], [20,"Ca","カルシウム","Calcium",4,2],
  [21,"Sc","スカンジウム","Scandium",4,3], [22,"Ti","チタン","Titanium",4,4],
  [23,"V","バナジウム","Vanadium",4,5], [24,"Cr","クロム","Chromium",4,6],
  [25,"Mn","マンガン","Manganese",4,7], [26,"Fe","鉄","Iron",4,8],
  [27,"Co","コバルト","Cobalt",4,9], [28,"Ni","ニッケル","Nickel",4,10],
  [29,"Cu","銅","Copper",4,11], [30,"Zn","亜鉛","Zinc",4,12],
  [31,"Ga","ガリウム","Gallium",4,13], [32,"Ge","ゲルマニウム","Germanium",4,14],
  [33,"As","ヒ素","Arsenic",4,15], [34,"Se","セレン","Selenium",4,16],
  [35,"Br","臭素","Bromine",4,17], [36,"Kr","クリプトン","Krypton",4,18]
];

const GROUPS_EXTRA = [
  // 1族：H, Li, Na, K, Rb, Cs, Fr
  [37,"Rb","ルビジウム","Rubidium",5,1], [55,"Cs","セシウム","Cesium",6,1], [87,"Fr","フランシウム","Francium",7,1],
  // 2族：Be, Mg, Ca, Sr, Ba, Ra
  [38,"Sr","ストロンチウム","Strontium",5,2], [56,"Ba","バリウム","Barium",6,2], [88,"Ra","ラジウム","Radium",7,2],
  // 17族：F, Cl, Br, I, At, Ts
  [53,"I","ヨウ素","Iodine",5,17], [85,"At","アスタチン","Astatine",6,17], [117,"Ts","テネシン","Tennessine",7,17],
  // 18族：He, Ne, Ar, Kr, Xe, Rn, Og
  [54,"Xe","キセノン","Xenon",5,18], [86,"Rn","ラドン","Radon",6,18], [118,"Og","オガネソン","Oganesson",7,18]
];

const ELEMENTS_ALL = [...BASE_SET_1to36, ...GROUPS_EXTRA]
  .map(([z,sym,jp,en,period,group])=>({z,sym,jp,en,period,group}))
  // period 1の無効マス（2-17族）などは後でisValidCellで管理
  .sort((a,b)=>a.z-b.z);

// 盤面：period=1..7, group=1..18
const ROWS = 7, COLS = 18;

/** 有効マス判定（MVP：period 1は1と18のみ。他は1..18を許容） */
function isValidCell(period, group) {
  if (period === 1) return group === 1 || group === 18; // H, He
  if (period >= 2 && period <= 7) return group >= 1 && group <= 18;
  return false;
}

// ===== DOM =====
const boardWrap = document.getElementById('boardWrap');
const boardEl = document.getElementById('board');
const fallingEl = document.getElementById('falling');
const scoreEl = document.getElementById('score');
const comboEl = document.getElementById('combo');
const missEl = document.getElementById('miss');
const placedEl = document.getElementById('placed');
const modeTag = document.getElementById('modeTag');
const toastEl = document.getElementById('toast');

// グリッド生成
const grid = [];
(function buildGrid(){
  boardEl.innerHTML = '';
  for (let r=1;r<=ROWS;r++){
    const rowArr = [];
    for (let c=1;c<=COLS;c++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.r = r; cell.dataset.c = c;
      if (!isValidCell(r,c)) cell.classList.add('invalid');
      const sm = document.createElement('div');
      sm.className = 'small';
      if (isValidCell(r,c)) sm.textContent = `${r},${c}`;
      cell.appendChild(sm);
      boardEl.appendChild(cell);
      rowArr.push({filled:false, el:cell});
    }
    grid.push(rowArr);
  }
})();

// ===== レイアウト：画面幅いっぱいにセルを自動調整 =====
function updateCellSize(){
  const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-gap'));
  const wrapW = boardWrap.clientWidth - 24; // 内側余白の目安
  const size = Math.max(20, Math.floor((wrapW - (COLS-1)*gap) / COLS));
  document.documentElement.style.setProperty('--cell-size', size + 'px');
}
window.addEventListener('resize', updateCellSize);
updateCellSize();

// ===== 状態 =====
let modeFocusGroups = false; // false: 全範囲, true: 族集中（1/2/17/18）
let score=0, combo=0, misses=0, placed=0;
let active=null; let timer=null; let paused=false;
const BASE_SPEED=900; let speed=BASE_SPEED;
const MAX_MISS=5;

// 既に配置された元素（z）
const placedSet = new Set();
// クリア対象（全範囲モードの全要素を基準に）
const TARGET_SET_ALL = new Set(ELEMENTS_ALL.map(e=>e.z));
const TARGET_SET_FOCUS = new Set(ELEMENTS_ALL.filter(e=>[1,2,17,18].includes(e.group)).map(e=>e.z));

function showToast(msg){ toastEl.textContent = msg; toastEl.classList.add('show'); setTimeout(()=>toastEl.classList.remove('show'), 900); }
function randChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

function pool(){
  const base = modeFocusGroups ? ELEMENTS_ALL.filter(e=>[1,2,17,18].includes(e.group)) : ELEMENTS_ALL;
  return base.filter(e=>!placedSet.has(e.z)); // 既に埋まっている元素は落とさない
}

function spawn(){
  const p = pool();
  if (p.length === 0){
    // クリア
    gameClear();
    return;
  }
  const e = randChoice(p);
  active = { ...e, x: Math.min(Math.max(e.group,1),COLS), y: 0 };
  fallingEl.querySelector('.sym').textContent = `${e.sym}`;
  fallingEl.querySelector('.jp').textContent = `${e.jp}`;
  fallingEl.style.display = 'grid';
  renderActive();
}

function renderActive(){
  if (!active) return;
  const size = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size'));
  const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-gap'));
  const cw = size + gap, ch = size + gap;
  const centerX = (active.x-1)*cw + size/2 + gap;
  // 目標行の中心
  const targetY = (active.period-1)*ch + size/2 + gap;
  const clampedY = Math.min(active.y, targetY);
  fallingEl.style.left = `${centerX}px`;
  fallingEl.style.top = `${clampedY}px`;
}

function step(){
  if (paused || !active) return;
  const size = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size'));
  const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-gap'));
  const ch = size + gap; const targetY = (active.period-1)*ch + size/2 + gap;
  active.y += Math.max(2, ch/8);
  if (active.y >= targetY - 1){
    const ok = (active.x === active.group);
    place(ok);
    return;
  }
  renderActive();
}

function place(ok){
  const r = active.period, c = active.group;
  const cell = grid[r-1][c-1];
  cell.filled = true; cell.el.classList.add('filled');
  cell.el.textContent = `${active.sym} ${active.jp}`;
  const sm = document.createElement('div'); sm.className='small'; sm.textContent = `${r},${c}`; cell.el.appendChild(sm);
  placedSet.add(active.z);

  if (ok){
    const add = 100 + combo*20; score += add; combo += 1; placed += 1; showToast(`正解！ +${add}`);
  } else {
    misses += 1; combo = 0; showToast(`ミス！ 正解は [${r},${c}]`);
  }
  updateHUD();
  fallingEl.style.display = 'none';
  active = null;

  // クリア判定（現在のモードのターゲットが全て埋まったら）
  const targetSet = modeFocusGroups ? TARGET_SET_FOCUS : TARGET_SET_ALL;
  let done = true; for (const z of targetSet){ if (!placedSet.has(z)) { done = false; break; } }
  if (done) { gameClear(); return; }
  if (misses >= MAX_MISS){ gameOver(); return; }
  spawn();
}

function updateHUD(){
  scoreEl.textContent = score; comboEl.textContent = combo; missEl.textContent = `${misses}/${MAX_MISS}`; placedEl.textContent = placed;
}

function clearBoard(){
  placedSet.clear();
  for (let r=1;r<=ROWS;r++){
    for (let c=1;c<=COLS;c++){
      const cell = grid[r-1][c-1];
      cell.filled = false; cell.el.className = 'cell' + (isValidCell(r,c)?'':' invalid');
      cell.el.textContent = '';
      const sm = document.createElement('div'); sm.className='small'; if (isValidCell(r,c)) sm.textContent = `${r},${c}`; cell.el.appendChild(sm);
    }
  }
}

function loop(){ step(); }

function start(reset=false){
  if (reset){ score=0; combo=0; misses=0; placed=0; clearBoard(); }
  updateHUD(); paused=false; speed=BASE_SPEED; if (timer) clearInterval(timer); timer = setInterval(loop, speed);
  if (!active) spawn();
}

function togglePause(){ if (!timer) return; paused = !paused; showToast(paused? '一時停止' : '再開'); }
function toggleMode(){ modeFocusGroups = !modeFocusGroups; modeTag.textContent = modeFocusGroups ? '族集中 (1/2/17/18)' : '全範囲'; showToast(modeFocusGroups? '族集中' : '全範囲'); }
function gameOver(){ clearInterval(timer); timer=null; active=null; showToast(`ゲームオーバー！ スコア:${score}`); }
function gameClear(){ clearInterval(timer); timer=null; active=null; showToast('クリア！おめでとう🎉'); }

// ===== 入力（キーボード） =====
function tickFastOnce(){ if (!active) return; const size = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size')); const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-gap')); const ch = size + gap; active.y += ch * .6; step(); }
function hardDrop(){ if (!active) return; const size = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size')); const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-gap')); const ch = size + gap; const targetY = (active.period-1)*ch + size/2 + gap; active.y = targetY; step(); }

document.addEventListener('keydown', (e)=>{
  if (!active && e.key === 'Enter'){ start(true); return; }
  if (e.key === 'Enter'){ start(true); return; }
  if (e.key.toLowerCase() === 'p'){ togglePause(); return; }
  if (e.key.toLowerCase() === 'm'){ toggleMode(); return; }
  if (!active) return;
  if (e.key === 'ArrowLeft'){ active.x = Math.max(1, active.x-1); renderActive(); }
  else if (e.key === 'ArrowRight'){ active.x = Math.min(COLS, active.x+1); renderActive(); }
  else if (e.key === 'ArrowDown'){ tickFastOnce(); }
  else if (e.code === 'Space'){ hardDrop(); }
  e.preventDefault();
});

// ===== タッチ操作（iPad） =====
let touchStartX=0, touchStartY=0, touchMoved=false;
const SWIPE_THRESHOLD = 24; // px
boardWrap.addEventListener('touchstart', (ev)=>{
  const t = ev.changedTouches[0]; touchStartX = t.clientX; touchStartY = t.clientY; touchMoved = false; }, {passive:true});
boardWrap.addEventListener('touchmove', (ev)=>{
  if (!active) return;
  const t = ev.changedTouches[0]; const dx = t.clientX - touchStartX; const dy = t.clientY - touchStartY;
  if (Math.abs(dx) > Math.abs(dy)){
    if (Math.abs(dx) > SWIPE_THRESHOLD){
      if (dx > 0){ active.x = Math.min(COLS, active.x+1); } else { active.x = Math.max(1, active.x-1); }
      renderActive(); touchStartX = t.clientX; touchStartY = t.clientY; touchMoved = true; // 連続移動可
    }
  } else {
    if (dy > SWIPE_THRESHOLD){ hardDrop(); touchMoved = true; }
  }
}, {passive:true});
boardWrap.addEventListener('touchend', (ev)=>{
  if (!active) return;
  if (!touchMoved){ tickFastOnce(); } // タップ：少し加速
});

// ===== ボタン =====
Document.prototype.q = Document.prototype.querySelector; // 小ワザ
const $ = (sel)=>document.querySelector(sel);
$('#restart').addEventListener('click', ()=>start(true));
$('#toggleMode').addEventListener('click', toggleMode);

// 自動開始
start(true);
</script>
</body>
</html>
