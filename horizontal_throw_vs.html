<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>水平投射 対戦ゲーム〜先に3つのハートをとれ！〜</title>
<style>
:root{
  --bg:#0f1220; --pane:#14182b; --card:#171a2b; --accent:#6ae3ff; --accent2:#8effa1;
  --text:#e8edf2; --muted:#9aa7b3; --ok:#8effa1; --ng:#ff9aa8; --yellow:#ffd36a;
  --topbar-h: 110px; 
  --a-tint: rgba(90,170,255,.12);
  --b-tint: rgba(255,90,120,.12);
  --a-fill: #6ab7ff;  /* Aリード表示=青 */
  --b-fill: #ff4a4a;  /* Bリード表示=赤 */

  --appH: 100vh;
  --topbar-real: 110px;
  --verdict-w: 12ch;
}

*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0; background:radial-gradient(1200px 600px at 70% -10%, #1a1f38, #0b0e1a 60%), var(--bg);
  color:var(--text); font-family: ui-sans-serif, -apple-system, "Hiragino Kaku Gothic ProN", Meiryo, "Noto Sans JP", system-ui, sans-serif;
  display:flex; min-height:100svh; align-items:stretch; justify-content:center;
  overflow:hidden;
}
@supports (min-height: 100dvh){ body{ min-height:100dvh; } }

.topbar{
  position:fixed; top:8px; left:50%; transform:translateX(-50%);
  display:flex; flex-direction:column; gap:10px; align-items:center; z-index:20;
  background:rgba(0,0,0,.25); border:1px solid rgba(255,255,255,.12);
  padding:10px 14px; border-radius:14px; backdrop-filter: blur(6px);
  height: var(--topbar-h);
  width:min(1100px, 94vw);
}
.toprow{ display:flex; gap:16px; align-items:center; justify-content:center; width:100%; }
.title{font-weight:800; letter-spacing:.02em}
.timer{font-variant-numeric: tabular-nums; font-weight:900; font-size:28px; color:#ffd36a}
.startBtn{
  appearance:none; border:none; border-radius:12px; padding:10px 14px; font-weight:800; cursor:pointer;
  color:#03131a; background:linear-gradient(180deg, #b1ffd1, #7affaf);
  box-shadow: 0 8px 22px rgba(122,255,175,.28), inset 0 1px 0 rgba(255,255,255,.6);
}

/* ▼ ハートUI */
.heartsWrap{ display:flex; align-items:center; justify-content:center; width:100%; }
.heartRow{ display:flex; align-items:center; gap:14px; }
.midgap{ width:28px; height:1px; }
.heart{ width:34px; height:34px; display:inline-block; }
.heart svg{ width:100%; height:100%; transform-origin:50% 55%; }
.heart .fill{ fill: transparent; }
.heart .outline{ fill:none; stroke:rgba(255,255,255,.7); stroke-width:2.2; stroke-dasharray:4 3; }
.heart.filledA .fill{ fill: var(--a-fill); }
.heart.filledB .fill{ fill: var(--b-fill); }
.heart.filledA .outline, .heart.filledB .outline{ stroke-dasharray:none; }
.heart.pop svg{ animation: heart-pop .28s ease-out; }
@keyframes heart-pop{
  0%{ transform: scale(0.65); filter: drop-shadow(0 0 0 rgba(255,255,255,0)); }
  70%{ transform: scale(1.15); filter: drop-shadow(0 0 8px rgba(255,255,255,.35)); }
  100%{ transform: scale(1.00); filter: drop-shadow(0 0 0 rgba(255,255,255,0)); }
}

/* ▼ アリーナ */
.arena {
  width: min(1400px, 100%);
  margin: 0 auto;
  padding: calc(var(--topbar-real) + 10px) 10px calc(10px + env(safe-area-inset-bottom));
  height: 100dvh;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
}

.pane{
  position:relative;
  background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,0));
  border:1px solid rgba(255,255,255,.08); border-radius:16px; padding:12px; 
  display:flex; flex-direction:column; min-height:0; overflow:hidden;
}
.pane::before{ content:""; position:absolute; inset:0; pointer-events:none; z-index:0; background:transparent; }
#paneA::before{ background: var(--a-tint); }
#paneB::before{ background: var(--b-tint); }
.pane > *{ position:relative; z-index:1; }

.pane header{
  display:flex; gap:10px; align-items:center; justify-content:space-between; margin-bottom:8px;
  flex:0 0 auto;
}
.name{font-weight:900; letter-spacing:.02em; font-size:20px}
.mutag{ font-size:20px; color:var(--muted); margin-left:8px; }

.challenge{
  display:grid; grid-template-columns: 1fr var(--verdict-w);
  align-items:center; gap:12px;
  margin-bottom:8px; font-weight:900; color:#ff5b5b;
}
.verdict{
  width:100%; text-align:right; white-space:nowrap;
  font-variant-numeric: tabular-nums; font-weight:900;
  font-size: clamp(18px, 2.6vw, 34px); line-height:1;
  visibility:hidden; opacity:0; transform: translateY(-4px) scale(.95);
  transition: opacity .18s ease, transform .18s ease, visibility 0s linear .18s;
}
.verdict.show{ visibility:visible; opacity:1; transform: translateY(0) scale(1); transition-delay:0s; }
.verdict.great{ color:#a7ff6a; }
.verdict.good { color:var(--ok); }
.verdict.ok   { color:#ffd36a; }
.verdict.bad  { color:var(--ng); }
@keyframes verdict-pop{
  0%{ transform: translateY(-6px) scale(.85); opacity:.0; }
  70%{ transform: translateY(0) scale(1.07); opacity:1; }
  100%{ transform: translateY(0) scale(1); opacity:1; }
}
.verdict.pop{ animation: verdict-pop .22s ease-out; }

.roulette{display:grid; grid-template-columns: 1fr auto; gap:10px; align-items:center; flex:0 0 auto;}
.bar{height:18px; background:#111528; border-radius:999px; overflow:hidden; position:relative; border:1px solid rgba(255,255,255,.08)}
.fill{height:100%; width:0%; background:linear-gradient(90deg, var(--accent), var(--accent2)); transition:width .06s linear; box-shadow:0 0 10px rgba(106,227,255,.6), inset 0 0 8px rgba(0,0,0,.3)}
.speed{font-variant-numeric: tabular-nums; font-weight:900; letter-spacing:.02em; min-width:9ch; text-align:right; font-size:clamp(18px, 2.6vw, 34px); color:#ff5b5b}

.actions{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; flex:0 0 auto;}
.btn{
  appearance:none; border:none; border-radius:12px; padding:14px 20px; font-weight:900; cursor:pointer;
  color:#03131a; background:linear-gradient(180deg, #8ff2ff, #6ae3ff);
  box-shadow: 0 8px 22px rgba(106,227,255,.35), inset 0 1px 0 rgba(255,255,255,.6);
  font-size: clamp(22px, 2.6vw, 34px);
}
.btn:disabled{opacity:.5; cursor:not-allowed}

/* ===== シーン（水平投射） ===== */
.gridWrap{
  display:grid; grid-template-columns: 1fr 240px; gap:10px; align-items:stretch;
  flex:1 1 auto; min-height:0;
}
.scene{
  position:relative; height:100%;
  border-radius:14px; overflow:hidden;
  background:
    linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,0)),
    radial-gradient(800px 260px at 50% 0%, rgba(106,227,255,.08), rgba(0,0,0,0) 60%),
    #0b1022;
  border:1px solid rgba(255,255,255,.08);
}
.ground{position:absolute; inset:auto 0 0 0; height:8px; background:#1a2039; box-shadow:0 -2px 0 rgba(255,255,255,.06) inset; z-index:0}
.meter{position:absolute; right:10px; top:10px; font-size:12px; color:var(--muted);
  background:rgba(0,0,0,.25); border:1px solid rgba(255,255,255,.08); padding:6px 8px; border-radius:8px; z-index:3}

.subground{position:absolute; left:0; right:0; background:linear-gradient(180deg, #8b5e3c, #5e3b23); opacity:.55; z-index:0}
.grid{position:absolute; inset:0 0 8px 0; pointer-events:none; z-index:0}
.hgridline,.vgridline,.zeroline{position:absolute; background:rgba(255,255,255,.22); opacity:.7}
.hgridline{left:8px; right:8px; height:1px;}
.vgridline{top:8px; bottom:8px; width:1px;}
.zeroline{left:8px; right:8px; height:2px; background:rgba(255,255,255,.28);}
.gridlabel{position:absolute; font-size:11px; color:var(--muted); background:rgba(0,0,0,.35); padding:1px 6px; border-radius:999px; border:1px solid rgba(255,255,255,.12); z-index:1}
.hlabel{ right:10px; transform:translateY(-50%); }
.vlabel{ transform:translateX(-50%); }

.building{
  position:absolute; left:0; right:auto;
  background:linear-gradient(180deg, #8f95a3, #6f7482);
  border:1px solid rgba(255,255,255,.1);
  box-shadow: inset 0 6px 14px rgba(0,0,0,.25);
  z-index:1;
}
.ball{
  position:absolute; width:18px; aspect-ratio:1; border-radius:50%;
  background: radial-gradient(circle at 30% 30%, #fff, #bfeaff 30%, #6ae3ff 45%, #0aa3c0 70%, #067089 100%);
  box-shadow: 0 8px 24px rgba(106,227,255,.45); z-index:2;
}
.target{
  position:absolute; width:14px; height:14px; border-radius:50%;
  border:2px solid #ffd36a; box-shadow:0 0 10px rgba(255,211,106,.5);
  transform:translate(-50%, 0%); z-index:2;
}
.target::after{content:''; position:absolute; inset:3px; border-radius:50%; border:2px solid rgba(255,211,106,.8);}

.readouts{display:grid; grid-template-columns: 1fr; gap:8px; overflow:auto;}
.stat{background:rgba(0,0,0,.25); border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:8px 10px}
.stat .label{color:var(--muted); font-size:12px; letter-spacing:.02em}
.stat .value{font-variant-numeric: tabular-nums; font-weight:900; font-size:20px}

.result{margin-top:6px; min-height:26px}
.great{color:#a7ff6a; font-weight:800}
.good{color:var(--ok); font-weight:800}
.ok{color:#ffd36a; font-weight:800}
.bad{color:var(--ng); font-weight:800}

.winner{
  position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:30;
  background:rgba(0,0,0,.55); backdrop-filter: blur(3px);
}
.winnerCard{
  background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.02));
  border:1px solid rgba(255,255,255,.18); padding:18px 22px; border-radius:16px; text-align:center;
  box-shadow: 0 20px 40px rgba(0,0,0,.35);
}
.winnerCard h2{ margin:0 0 8px; }
.winnerBtns{ margin-top:10px; display:flex; gap:10px; justify-content:center; }
.overlayPortrait{
  position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:40;
  background:#0b0f20; color:#fff; text-align:center; padding:24px;
}
@media (orientation: portrait){
  .overlayPortrait{ display:flex; }
}
body.prestart .challenge{ display:none; }
body.prestart .btn{ pointer-events: none; opacity: .6; }
</style>
</head>
<body class="prestart">
  <div class="overlayPortrait">
    <div>
      <h2>横画面にしてください</h2>
      <p>この対戦版は横向き専用です。端末を横に回転してください。</p>
    </div>
  </div>

  <div class="topbar">
    <div class="toprow">
      <div class="title">水平投射 対戦ゲーム〜先に3つのハートをとれ！〜</div>
      <div class="timer" id="timer">120.0</div>
      <button class="startBtn" id="startBtn">対戦スタート</button>
    </div>
    <div class="heartsWrap" id="heartsWrap"><div class="heartRow" id="heartRow"></div></div>
  </div>

  <main class="arena">
    <!-- ===== Pane A ===== -->
    <section class="pane" id="paneA">
      <header>
        <div class="name">プレイヤーA <span class="mutag" id="mulA">ルーレット速度 ×1.0</span></div>
        <div></div>
      </header>

      <div class="challenge">
        <span id="challengeAText">—</span>
        <span class="verdict" id="verdictA"></span>
      </div>

      <div class="roulette" aria-label="初速ルーレット（0〜6 m/s を4秒基準で周回）">
        <div class="bar"><div class="fill" id="fillA"></div></div>
        <div class="speed" id="speedA">0.00 m/s</div>
      </div>

      <div class="actions">
        <button class="btn" id="fireA" disabled>投射！(Aキー)</button>
      </div>

      <div class="gridWrap">
        <div class="scene" id="sceneA">
          <div class="meter">g = 9.8 m/s²</div>
          <div class="subground" id="subA"></div>
          <div class="grid" id="gridA"></div>
          <div class="building" id="bldA"></div>
          <div class="target" id="targetA"></div>
          <div class="ball" id="ballA"></div>
          <div class="ground"></div>
        </div>
        <div class="readouts">
          <div class="stat"><div class="label">現在位置 (x, y)</div><div class="value" id="posNowA">0.00 m, 0.00 m</div></div>
          <div class="stat"><div class="label">飛行時間 T</div><div class="value" id="tValA">0.00 s</div></div>
          <div class="stat"><div class="label">着地点 xₗ</div><div class="value" id="xLandA">0.00 m</div></div>
          <div class="result" id="resultA"></div>
        </div>
      </div>
    </section>

    <!-- ===== Pane B ===== -->
    <section class="pane" id="paneB">
      <header>
        <div class="name">プレイヤーB <span class="mutag" id="mulB">ルーレット速度 ×1.0</span></div>
        <div></div>
      </header>

      <div class="challenge">
        <span id="challengeBText">—</span>
        <span class="verdict" id="verdictB"></span>
      </div>

      <div class="roulette" aria-label="初速ルーレット（0〜6 m/s を4秒基準で周回）">
        <div class="bar"><div class="fill" id="fillB"></div></div>
        <div class="speed" id="speedB">0.00 m/s</div>
      </div>

      <div class="actions">
        <button class="btn" id="fireB" disabled>投射！(Lキー)</button>
      </div>

      <div class="gridWrap">
        <div class="scene" id="sceneB">
          <div class="meter">g = 9.8 m/s²</div>
          <div class="subground" id="subB"></div>
          <div class="grid" id="gridB"></div>
          <div class="building" id="bldB"></div>
          <div class="target" id="targetB"></div>
          <div class="ball" id="ballB"></div>
          <div class="ground"></div>
        </div>
        <div class="readouts">
          <div class="stat"><div class="label">現在位置 (x, y)</div><div class="value" id="posNowB">0.00 m, 0.00 m</div></div>
          <div class="stat"><div class="label">飛行時間 T</div><div class="value" id="tValB">0.00 s</div></div>
          <div class="stat"><div class="label">着地点 xₗ</div><div class="value" id="xLandB">0.00 m</div></div>
          <div class="result" id="resultB"></div>
        </div>
      </div>
    </section>
  </main>

  <div class="winner" id="winner">
    <div class="winnerCard">
      <h2 id="winnerTitle">結果</h2>
      <div id="winnerDetail"></div>
      <div class="winnerBtns">
        <button class="startBtn" id="restartBtn">もう一度</button>
      </div>
    </div>
  </div>

<script>
(() => {
  /* ===== 画面・共通設定 ===== */
  const g = 9.8;
  const vMin=0, vMax=6, baseCycleSec=4.0;

  // 水平投射の候補
  const Y_CANDIDATES = [4.9, 19.6, 44.1];
  // 高さごとに許可するターゲットxの候補
  const TARGET_BY_HEIGHT = {
    '4.9':  [1,2,3,4,5],
    '19.6': [3,4,5],
    '44.1': [3,4,5],
  };
  const H_LINES = [4.9,9.8,14.7,19.6,24.5,29.4,34.3,39.2,44.1];
  const X_GRID_MAX = 5;
  const BOTTOM_VISIBLE_M = 3.2;
  const Y_MAX_VISIBLE = 50;

  /* ===== ハートUI ===== */
  const heartRow = document.getElementById('heartRow');
  const HEART_SVG = `
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <path class="fill" d="M12 21s-6.7-4.35-9.33-7.33C-0.3 10.75 1.1 5.7 5.2 5.2 7.3 4.95 9 6.1 12 8.7c3-2.6 4.7-3.75 6.8-3.5 4.1.5 5.5 5.55 2.53 8.47C18.7 16.65 12 21 12 21z"/>
      <path class="outline" d="M12 21s-6.7-4.35-9.33-7.33C-0.3 10.75 1.1 5.7 5.2 5.2 7.3 4.95 9 6.1 12 8.7c3-2.6 4.7-3.75 6.8-3.5 4.1.5 5.5 5.55 2.53 8.47C18.7 16.65 12 21 12 21z"/>
    </svg>`;
  const heartsB = [], heartsA = [];
  function makeHeart(side){ const d=document.createElement('div'); d.className='heart'; d.dataset.side=side; d.innerHTML=HEART_SVG; return d; }
  for(let i=0;i<3;i++){ const h=makeHeart('B'); heartRow.appendChild(h); heartsB.push(h); }
  const mg=document.createElement('div'); mg.className='midgap'; heartRow.appendChild(mg);
  for(let i=0;i<3;i++){ const h=makeHeart('A'); heartRow.appendChild(h); heartsA.push(h); }
  function pop(el){ el.classList.remove('pop'); void el.offsetWidth; el.classList.add('pop'); }
  function renderHeartsFromPos(pos){
    const leftCount = Math.max(0,pos); const rightCount = Math.max(0,-pos);
    heartsB.forEach((el,i)=>{ const on=(i>=(3-leftCount)); const was=el.classList.contains('filledA'); el.classList.toggle('filledA',on); el.classList.remove('filledB'); if(on&&!was) pop(el); });
    heartsA.forEach((el,i)=>{ const on=(i<rightCount); const was=el.classList.contains('filledB'); el.classList.toggle('filledB',on); el.classList.remove('filledA'); if(on&&!was) pop(el); });
  }
  renderHeartsFromPos(0);

  /* ===== サウンド ===== */
  let audioCtx=null;
  function beep(freq=880,duration=0.15,type='sine',gain=0.08){
    try{
      if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)();
      const t0=audioCtx.currentTime;
      const osc=audioCtx.createOscillator(); const gnode=audioCtx.createGain();
      osc.type=type; osc.frequency.value=freq; gnode.gain.value=gain;
      osc.connect(gnode).connect(audioCtx.destination);
      osc.start(t0);
      gnode.gain.setValueAtTime(gain,t0);
      gnode.gain.exponentialRampToValueAtTime(0.0001,t0+duration);
      osc.stop(t0+duration+0.02);
    }catch(e){}
  }
  const okSound = ()=>beep(740,0.12);
  const goodSound = ()=>{beep(880,0.12); setTimeout(()=>beep(1175,0.12),120);};
  const greatSound= ()=>{beep(1047,0.10); setTimeout(()=>beep(1319,0.10),110); setTimeout(()=>beep(1661,0.14),230);};
  const wrongSound= ()=>{beep(220,0.25,'square',0.06); setTimeout(()=>beep(175,0.25,'square',0.05),120);};

  /* ===== 水平投射 Duel クラス ===== */
  class HorizontalDuel {
    constructor(prefix){
      this.p = prefix;
      this.enemy = null;
      this.debuffMul = 1.0;
      this.locked = false;
      this.running = false;
      this.t0Roulette = 0;

      // DOM
      this.scene  = document.getElementById('scene'+prefix);
      this.sub    = document.getElementById('sub'+prefix);
      this.grid   = document.getElementById('grid'+prefix);
      this.build  = document.getElementById('bld'+prefix);
      this.ball   = document.getElementById('ball'+prefix);
      this.target = document.getElementById('target'+prefix);
      this.fill   = document.getElementById('fill'+prefix);
      this.speedL = document.getElementById('speed'+prefix);
      this.fireBtn= document.getElementById('fire'+prefix);
      this.verdictEl = document.getElementById('verdict'+prefix);
      this.challengeLabel = document.getElementById('challenge'+prefix+'Text');
      this.posNowEl = document.getElementById('posNow'+prefix);
      this.tValEl   = document.getElementById('tVal'+prefix);
      this.xLandEl  = document.getElementById('xLand'+prefix);
      this.resultEl = document.getElementById('result'+prefix);
      this.mulTag   = document.getElementById(prefix==='A'?'mulA':'mulB');

      // 状態
      this.y0 = 19.6;
      this.xTarget = 3;
      this.curX = 0; this.curY = 0;
      this.scaleX = 40; this.scaleY = 8;
      this.origin = { x: 30, y: 8 };
      this.groundOffsetPx = 8;
      this.prevCombo = null;
      this.inFlight = false;
      this.onLanded = null;

      // クリック
      this.fireBtn.addEventListener('click', ()=>{
        if(this.locked || this.fireBtn.disabled) return;
        this.locked = true; this.fireBtn.disabled = true;
        const v=parseFloat(this.speedL.textContent.replace(' m/s',''));
        this.animateThrow(v);
      });

      this.fitScales();
      this.renderGrid();
      this.layoutStatics();
      this.placeBallAt(0,this.y0);
      this.pickChallenge();
      this.updateMulUI();
      this.updateSpeedUI(0);
    }

    /* ---- レイアウト/座標 ---- */
    toPxX(xm){ return this.origin.x + xm*this.scaleX; }
    toPxY(ym){ return this.origin.y + ym*this.scaleY; }

    fitScales(){
      const usableH = this.scene.clientHeight;
      const usableW = this.scene.clientWidth - this.origin.x - 16;
      this.scaleY = Math.max(4, (usableH) / (Y_MAX_VISIBLE + BOTTOM_VISIBLE_M));
      this.scaleX = Math.max(24, Math.min(90, usableW / (X_GRID_MAX + 0.6)));
      this.origin.y = this.groundOffsetPx + (BOTTOM_VISIBLE_M * this.scaleY);
    }

    renderGrid(){
      const gridEl=this.grid; gridEl.innerHTML='';
      for(const ym of H_LINES){
        const line=document.createElement('div'); line.className='hgridline';
        line.style.bottom=this.toPxY(ym)+'px'; gridEl.appendChild(line);
        const lab=document.createElement('div'); lab.className='gridlabel hlabel';
        lab.style.bottom=this.toPxY(ym)+'px'; lab.textContent=`${ym} m`; gridEl.appendChild(lab);
      }
      const zero=document.createElement('div'); zero.className='zeroline';
      zero.style.bottom=this.toPxY(0)+'px'; gridEl.appendChild(zero);
      const lab0=document.createElement('div'); lab0.className='gridlabel hlabel';
      lab0.style.bottom=this.toPxY(0)+'px'; lab0.textContent='0 m'; gridEl.appendChild(lab0);

      const yLabPx=this.toPxY(-2.6);
      for(let xm=0; xm<=X_GRID_MAX; xm++){
        const v=document.createElement('div'); v.className='vgridline';
        v.style.left=this.toPxX(xm)+'px'; gridEl.appendChild(v);
        const l=document.createElement('div'); l.className='gridlabel vlabel';
        l.style.left=this.toPxX(xm)+'px'; l.style.bottom=yLabPx+'px'; l.textContent=`${xm} m`; gridEl.appendChild(l);
      }
    }

    layoutStatics(){
      // サブグラウンド
      this.sub.style.bottom = (this.toPxY(-BOTTOM_VISIBLE_M))+'px';
      this.sub.style.height = (BOTTOM_VISIBLE_M*this.scaleY)+'px';
      // 建物（x<0 域）
      const rightPx = this.origin.x;
      this.build.style.right = (this.scene.clientWidth - rightPx) + 'px';
      this.build.style.left = '0px';
      this.build.style.bottom = this.toPxY(0) + 'px';
      this.build.style.height = (this.y0 * this.scaleY) + 'px';
      // ターゲット
      this.target.style.left = this.toPxX(this.xTarget) + 'px';
      this.target.style.bottom = this.toPxY(0) + 'px';
    }

    placeBallAt(xm,ym){
      this.curX=xm; this.curY=ym;
      this.ball.style.left = (this.toPxX(xm) - 9) + 'px';
      this.ball.style.bottom = this.toPxY(ym) + 'px';
    }

    /* ---- ルーレット ---- */
    updateMulUI(){ this.mulTag.textContent = `ルーレット速度 ×${this.debuffMul.toFixed(1)}`; }
    applyDebuff(f){ this.debuffMul = Math.min(this.debuffMul * f, 64); this.updateMulUI(); }
    clearDebuff(){ this.debuffMul = 1.0; this.updateMulUI(); }

    startRoulette(){
      this.running = true; this.t0Roulette=performance.now();
      const loop=(now)=>{
        if(!this.running) return;
        const elapsed=(now-this.t0Roulette)/1000;
        const effectiveCycle = baseCycleSec / this.debuffMul;
        const v = vMin + ((elapsed % effectiveCycle)/effectiveCycle) * (vMax - vMin);
        this.updateSpeedUI(v);
        requestAnimationFrame(loop);
      };
      requestAnimationFrame(loop);
    }
    stopRoulette(){ this.running = false; }
    updateSpeedUI(v){
      const c=Math.max(vMin,Math.min(vMax,v));
      const ratio=(c-vMin)/(vMax-vMin);
      this.fill.style.width=(ratio*100).toFixed(2)+'%';
      this.speedL.textContent=c.toFixed(2)+' m/s';
    }

    /* ---- 課題 ---- */
    pickChallenge(){
      // 前回と同一の {y0,x} を避けつつ、高さに応じてx候補を制限
      let y, x, safety=32;
      do{
        y = Y_CANDIDATES[Math.floor(Math.random()*Y_CANDIDATES.length)];
        const allowed = TARGET_BY_HEIGHT[y.toFixed(1)] || TARGET_BY_HEIGHT['4.9'];
        x = allowed[Math.floor(Math.random()*allowed.length)];
      }while(this.prevCombo && this.prevCombo.y===y && this.prevCombo.x===x && --safety>0);
      this.y0=y; this.xTarget=x; this.prevCombo={y,x};
      this.challengeLabel.textContent = `初期高さ y₀ = ${y.toFixed(1)} m｜ターゲット x = ${x} m を狙え！`;
      // レイアウト再計算
      this.fitScales(); this.renderGrid(); this.layoutStatics();
      this.placeBallAt(0,this.y0);
      // 表示初期化
      this.posNowEl.textContent = `0.00 m, ${this.y0.toFixed(2)} m`;
      this.tValEl.textContent = '0.00 s';
      this.xLandEl.textContent = '0.00 m';
      // 右側判定欄はNBSPで幅保持
      if(this.verdictEl){ this.verdictEl.className='verdict'; this.verdictEl.textContent='\u00A0'; }
      this.resultEl.textContent='';
    }

    /* ---- 投射 ---- */
    animateThrow(v0){
      this.inFlight = true;
      const tFlight = Math.sqrt((2*this.y0)/g);
      const xLand = v0 * tFlight;

      // 判定欄消し（幅保持）
      if(this.verdictEl){ this.verdictEl.className='verdict'; this.verdictEl.textContent='\u00A0'; }

      const start=performance.now();
      const step=(now)=>{
        const t=(now-start)/1000;
        const tC = Math.min(tFlight, Math.max(0,t));
        const x = v0 * tC;
        const y = Math.max(0, this.y0 - 0.5*g*tC*tC);

        this.placeBallAt(x,y);
        this.posNowEl.textContent = `${x.toFixed(2)} m, ${y.toFixed(2)} m`;
        this.tValEl.textContent   = tC.toFixed(2)+' s';
        this.xLandEl.textContent  = xLand.toFixed(2)+' m';

        if(t < tFlight - 1e-3){
          requestAnimationFrame(step);
        }else{
          this.placeBallAt(xLand,0);
          this.evaluateAndContinue(xLand, tFlight);
          this.inFlight = false;
          if (typeof this.onLanded === 'function') this.onLanded();
        }
      };
      requestAnimationFrame(step);
    }

    evaluateAndContinue(xLand, tFlight){
      const errPct = Math.abs(xLand - this.xTarget) / this.xTarget;
      let verdict='miss', verdictText='miss…', vClass='bad', sound=wrongSound;

      if (errPct < 0.03){ verdict='excellent'; verdictText='Excellent!!!'; vClass='great'; sound=greatSound; }
      else if (errPct < 0.10){ verdict='great'; verdictText='great!!'; vClass='great'; sound=greatSound; }
      else if (errPct < 0.20){ verdict='good'; verdictText='good!'; vClass='good'; sound=goodSound; }
      else if (errPct < 0.30){ verdict='ok'; verdictText='ok'; vClass='ok'; sound=okSound; }

      const pctText=(errPct*100).toFixed(1)+'%';
      if (verdict==='excellent'){
        this.resultEl.innerHTML = `<span class="great">Excellent!!!（誤差 ${pctText}）</span>`;
      } else if (verdict==='great'){
        this.resultEl.innerHTML = `<span class="great">great!!（誤差 ${pctText}）</span>`;
      } else if (verdict==='good'){
        this.resultEl.innerHTML = `<span class="good">good!（誤差 ${pctText}）</span>`;
      } else if (verdict==='ok'){
        this.resultEl.innerHTML = `<span class="ok">ok（誤差 ${pctText}）</span>`;
      } else {
        this.resultEl.innerHTML = `<span class="bad">miss…（誤差 ${pctText}）</span>`;
      }
      sound();

      // 大判定（課題右）
      if(this.verdictEl){
        const el=this.verdictEl;
        el.className='verdict'; el.textContent=verdictText;
        el.classList.add(vClass,'show','pop');
        setTimeout(()=>el.classList.remove('pop'), 260);
        setTimeout(()=>{ el.className='verdict'; el.textContent='\u00A0'; }, 3000);
      }

      // tug（good 以上で1マス） & デバフ
      if (verdict==='excellent' || verdict==='great' || verdict==='good'){
        tugMove(this.p==='A' ? +1 : -1);
        const factor = (verdict==='excellent') ? 2.2 : (verdict==='great' ? 2.0 : 1.5);
        this.enemy.applyDebuff(factor);
      }
      // 自分は ok 以上でデバフ解除
      if (verdict!=='miss'){ this.clearDebuff(); }

      // miss 以外のときだけ新しい課題を出す
if (verdict !== 'miss') {
  this.pickChallenge();
}
this.fireBtn.disabled = false;
this.locked = false;
    }

    /* ---- ライフサイクル ---- */
    enablePlay(on){ this.fireBtn.disabled = !on; }
    onStart(){ this.enablePlay(true); this.startRoulette(); }
    onStop(){ this.enablePlay(false); this.stopRoulette(); this.locked=true; }
    reset(){
      this.stopRoulette();
      this.locked=false; this.fireBtn.disabled=true;
      this.fitScales(); this.renderGrid(); this.pickChallenge();
      this.clearDebuff();
    }
    onTimeUp(){ this.stopRoulette(); this.fireBtn.disabled=true; }
  }

  /* ===== 試合進行 ===== */
  const timerEl = document.getElementById('timer');
  const startBtn = document.getElementById('startBtn');
  const winner = document.getElementById('winner');
  const winnerTitle = document.getElementById('winnerTitle');
  const winnerDetail = document.getElementById('winnerDetail');
  const restartBtn = document.getElementById('restartBtn');

  const A = new HorizontalDuel('A');
  const B = new HorizontalDuel('B');
  A.enemy = B; B.enemy = A;

  let tugPos = 0;       // -3 〜 +3
  function tugMove(by){
    tugPos = Math.max(-3, Math.min(3, tugPos + by));
    renderHeartsFromPos(tugPos);
    if (tugPos === 3) showWinnerImmediate('A');
    if (tugPos === -3) showWinnerImmediate('B');
  }

  let timeUp=false, pendingLandings=0;
  let tRemain = 120.0;
  let ticking=false, rafId=null, lastTs=0;

  function tick(ts){
    if(!ticking) return;
    if(!lastTs) lastTs=ts;
    const dt=(ts-lastTs)/1000; lastTs=ts;
    tRemain = Math.max(0, tRemain - dt);
    timerEl.textContent = tRemain.toFixed(1);
    if(tRemain>0){ rafId=requestAnimationFrame(tick); }
    else{
      ticking=false; timeUp=true;
      A.onTimeUp(); B.onTimeUp();
      pendingLandings = (A.inFlight?1:0) + (B.inFlight?1:0);
      if(pendingLandings===0){ showWinnerByHearts(); }
      else{
        const landedOnce=()=>{ pendingLandings=Math.max(0,pendingLandings-1); if(pendingLandings===0){ showWinnerByHearts(); A.onLanded=null; B.onLanded=null; } };
        A.onLanded=landedOnce; B.onLanded=landedOnce;
      }
    }
  }

  function showWinnerByHearts(){
    if (tugPos>0) showWinnerImmediate('A', true);
    else if (tugPos<0) showWinnerImmediate('B', true);
    else showDraw(true);
  }
  function showWinnerImmediate(who, timed=false){
    winnerTitle.textContent = `勝者：プレイヤー${who}`;
    const reason = timed ? '（120秒終了時点）' : '（3つのハートを先取）';
    const aCnt = Math.max(0, tugPos), bCnt = Math.max(0, -tugPos);
    winnerDetail.textContent = `A：${aCnt}  /  B：${bCnt}  ${reason}`;
    winner.style.display='flex';
  }
  function showDraw(timed=false){
    winnerTitle.textContent = '引き分け';
    const aCnt = Math.max(0, tugPos), bCnt = Math.max(0, -tugPos);
    const reason = timed ? '（120秒終了時点）' : '';
    winnerDetail.textContent = `A：${aCnt}  /  B：${bCnt}  ${reason}`;
    winner.style.display='flex';
  }
  function hideWinner(){ winner.style.display='none'; }

  function startMatch(){
    hideWinner();
    document.body.classList.remove('prestart');
    timeUp=false; tRemain=120.0; timerEl.textContent=tRemain.toFixed(1);
    lastTs=0; ticking=true;
    tugPos=0; renderHeartsFromPos(0);
    A.reset(); B.reset();
    A.onStart(); B.onStart();
    requestAnimationFrame(tick);
  }
  function prepareNext(){
    hideWinner();
    ticking=false; if(rafId) cancelAnimationFrame(rafId); lastTs=0;
    tRemain=120.0; timerEl.textContent=tRemain.toFixed(1);
    tugPos=0; renderHeartsFromPos(0);
    A.reset(); B.reset();
    A.enablePlay(false); B.enablePlay(false);
    document.body.classList.add('prestart');
  }

  startBtn.addEventListener('click', startMatch);
  restartBtn.addEventListener('click', prepareNext);

  // キーボード操作
  window.addEventListener('keydown', (e)=>{
    if (e.repeat || timeUp) return;
    const key=e.key.toLowerCase();
    if (key==='a' && !A.fireBtn.disabled && !A.locked) A.fireBtn.click();
    if (key==='l' && !B.fireBtn.disabled && !B.locked) B.fireBtn.click();
  });

  // リサイズでスケール再計算
  function fitScenes(){
    A.fitScales(); A.renderGrid(); A.layoutStatics(); A.placeBallAt(0, A.y0);
    B.fitScales(); B.renderGrid(); B.layoutStatics(); B.placeBallAt(0, B.y0);
  }
  window.addEventListener('resize', fitScenes);
  window.addEventListener('orientationchange', ()=>setTimeout(fitScenes, 150));
  window.addEventListener('DOMContentLoaded', ()=>setTimeout(fitScenes, 50));

  /* 端末の可視高さをCSSへ（iPad等の下切れ対策） */
  function updateAppHeight(){
    const vh = (window.visualViewport ? window.visualViewport.height : window.innerHeight);
    const topbar = document.querySelector('.topbar');
    const topbarH = topbar ? Math.ceil(topbar.offsetHeight) : 110;
    const root = document.documentElement;
    root.style.setProperty('--appH', vh + 'px');
    root.style.setProperty('--topbar-real', topbarH + 'px');
  }
  window.addEventListener('DOMContentLoaded', ()=>{ updateAppHeight(); setTimeout(updateAppHeight,50); });
  window.addEventListener('resize', updateAppHeight);
  window.addEventListener('orientationchange', ()=>setTimeout(updateAppHeight,150));
  if (window.visualViewport){ window.visualViewport.addEventListener('resize', updateAppHeight); }
})();
</script>
</body>
</html>
