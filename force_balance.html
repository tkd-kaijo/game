<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>åŠ›ã®ã¤ã‚Šåˆã„ã‚²ãƒ¼ãƒ ã€œåŠ›ã‚’åŠ ãˆã¦ã¤ã‚Šåˆã‚ã›ã‚ï¼ã€œ</title>
<style>
  :root {
    --bg:#0f1117; --panel:#161a22; --ink:#e6edf3; --muted:#9aa4b2;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Noto Sans JP,sans-serif;}
  .wrap{max-width:980px;margin:24px auto;padding:0 16px;}
  header{display:flex;gap:12px;align-items:center;justify-content:space-between;margin-bottom:12px;flex-wrap:wrap}
  h1{font-size:20px;margin:0;font-weight:700;letter-spacing:.02em}
  .hud{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  .pill{padding:6px 10px;border-radius:999px;background:var(--panel);color:var(--ink);border:1px solid #222836}
  .pill b{font-variant-numeric:tabular-nums}
  button{all:unset;cursor:pointer;padding:10px 14px;border-radius:10px;background:linear-gradient(180deg,#1c2331,#141923);border:1px solid #1e2432}
  button:hover{filter:brightness(1.05)}
  button:disabled{opacity:.5;cursor:not-allowed}
  #canvasBox{background:var(--panel);border:1px solid #1e2432;border-radius:16px;padding:12px}
  #canvas{width:100%;height:auto;display:block;background:linear-gradient(180deg,#151a23,#131722);border-radius:12px}
  .msg{margin-top:10px;min-height:28px;color:var(--muted)}
  .legend{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-top:8px;color:var(--muted);font-size:14px}
  .chip{display:inline-flex;gap:6px;align-items:center;padding:4px 8px;border-radius:999px;background:#121722;border:1px solid #252c3b}
  .dot{width:12px;height:12px;border-radius:50%}
  .c-blue{background:#69b7ff}
  .c-green{background:#7dffa7}
  .c-purple{background:#c59eff}
  .c-yellow{background:#ffd166}
  .footer{margin-top:16px;color:var(--muted);font-size:14px}
  .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace;background:#0e1220;padding:2px 6px;border:1px solid #242a3a;border-radius:6px}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>åŠ›ã®ã¤ã‚Šåˆã„ã‚²ãƒ¼ãƒ ã€œåŠ›ã‚’åŠ ãˆã¦ã¤ã‚Šåˆã‚ã›ã‚ï¼ã€œ</h1>
    <div class="hud">
      <div class="pill">ãƒ©ã‚¦ãƒ³ãƒ‰ï¼š<b id="roundLabel">0 / 5</b></div>
      <div class="pill">ã‚¿ã‚¤ãƒ ï¼š<b id="timeLabel">0.00s</b></div>
      <div class="pill">åˆ¶é™ï¼š<b id="limitLabel">--</b></div>
      <button id="startBtn">ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
      <button id="resetBtn" disabled>ãƒªã‚»ãƒƒãƒˆ</button>
    </div>
  </header>

  <div id="canvasBox">
    <canvas id="canvas" width="720" height="720"></canvas>
    <div class="legend">
      <span class="chip"><span class="dot c-blue"></span>è¡¨ç¤ºä¸­ã®åŠ›â‘ </span>
      <span class="chip"><span class="dot c-green"></span>è¡¨ç¤ºä¸­ã®åŠ›â‘¡</span>
      <span class="chip"><span class="dot c-purple"></span>ã‚ãªãŸã®è§£ç­”ï¼ˆãƒ‰ãƒ©ãƒƒã‚°ä¸­/æå‡ºæ¸ˆï¼‰</span>
      <span class="chip"><span class="dot c-yellow"></span>æ­£è§£ï¼ˆãƒ©ã‚¦ãƒ³ãƒ‰çµ‚äº†æ™‚ï¼‰</span>
      <span class="chip">8Ã—8ãƒã‚¹ï¼ˆäº¤ç‚¹ã¯9Ã—9ï¼‰ï¼ä¸­å¤®ã®äº¤ç‚¹ã«ç‰©ä½“</span>
    </div>
    <div class="msg" id="msg">[æ“ä½œ] ä¸­å¤®ã‹ã‚‰ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦çŸ¢å°ã‚’å¼•ãã€é›¢ã™ã¨æœ€è¿‘å‚ã®äº¤ç‚¹ã«ã‚¹ãƒŠãƒƒãƒ—ã€‚1å›ã§ã‚‚èª¤ç­”ã‹æ™‚é–“åˆ‡ã‚Œã§ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã€‚</div>
  </div>

  <div class="footer">
    ãƒ’ãƒ³ãƒˆï¼š3ã¤ã®åŠ›ã®ãƒ™ã‚¯ãƒˆãƒ«å’Œã¯ <span class="kbd">0</span>ã€‚è¡¨ç¤ºã®2æœ¬ <span class="kbd">Fâ‚</span>, <span class="kbd">Fâ‚‚</span> ã«å¯¾ã—ã¦æ¬ ã‘ãŸåŠ›ã¯ <span class="kbd">Fâ‚ƒ = âˆ’(Fâ‚ + Fâ‚‚)</span>ã€‚
  </div>
</div>

<script>
(() => {
  // ====== åŸºæœ¬è¨­å®š ======
  const gridSquares = 8;                   // â˜… 8Ã—8ãƒã‚¹
  const points = gridSquares + 1;          // äº¤ç‚¹ã¯ 9 Ã— 9
  const centerIndex = Math.floor(points/2);// ä¸­å¤®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆ0åŸºæº–ï¼‰
  const margin = 28;                       // ä½™ç™½ï¼ˆpxï¼‰
  const maxSeconds = 40.0;                 // åˆ¶é™æ™‚é–“ 40ç§’
  const totalRounds = 5;

  // ====== ã‚­ãƒ£ãƒ³ãƒã‚¹ & DPI è£œæ­£ ======
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  function fitCanvasDPI(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const box = canvas.parentElement || document.body;
    const boxRect = box.getBoundingClientRect();
    // ç”»é¢ä¸‹ç«¯ã¾ã§ã®æ®‹ã‚Šé«˜ã•ï¼ˆãƒœãƒƒã‚¯ã‚¹ä¸Šè¾ºã‹ã‚‰ä¸‹ç«¯ã¾ã§ï¼‰
    const remainH = Math.max(220, window.innerHeight - boxRect.top - 24);
    const availW  = box.clientWidth || boxRect.width;
    const cssSize = Math.max(200, Math.floor(Math.min(availW, remainH)));
    const size = Math.floor(cssSize * dpr);
    canvas.width = size; canvas.height = size;
    canvas.style.width = (size/dpr) + 'px';
    canvas.style.height = (size/dpr) + 'px';
  }
  requestAnimationFrame(() => { fitCanvasDPI(); draw(); });
  window.addEventListener('resize', () => { fitCanvasDPI(); draw(); });
  window.addEventListener('orientationchange', () => setTimeout(()=>{ fitCanvasDPI(); draw(); }, 60));

  // åº§æ¨™å¤‰æ›
  function spacing(){ return (Math.min(canvas.width, canvas.height) - margin*2) / gridSquares; }
  function ijToXY(i,j){ const s = spacing(); return { x: margin + i*s, y: margin + j*s }; }
  function xyToIJ(x,y){
    const s = spacing();
    let i = Math.round((x - margin) / s);
    let j = Math.round((y - margin) / s);
    i = Math.max(0, Math.min(points-1, i));
    j = Math.max(0, Math.min(points-1, j));
    return {i,j};
  }

  // ====== ã‚²ãƒ¼ãƒ çŠ¶æ…‹ ======
  let round = 0;
  let startTime = null;
  let timerId = null;
  let playing = false;
  let awaitingAnswer = false;
  let forces = null;       // {A:{i,j}, B:{i,j}, C:{i,j}}
  let lastAnswer = null;   // æå‡ºæ¸ˆã¿ {i,j}
  let revealCorrect = false;
  let gameOverFlag = false;

  // ãƒ‰ãƒ©ãƒƒã‚°å…¥åŠ›çŠ¶æ…‹
  let dragging = false;
  let dragPos = null;      // {x,y}ï¼ˆã‚­ãƒ£ãƒ³ãƒã‚¹åº§æ¨™ï¼‰
  const startFromCenterRadiusFactor = 0.5; // ä¸­å¤®è¿‘å‚ã‹ã‚‰ã®ã¿é–‹å§‹

  const msgEl = document.getElementById('msg');
  const roundLabel = document.getElementById('roundLabel');
  const timeLabel  = document.getElementById('timeLabel');
  const limitLabel = document.getElementById('limitLabel');
  const startBtn   = document.getElementById('startBtn');
  const resetBtn   = document.getElementById('resetBtn');
  if(limitLabel) limitLabel.textContent = maxSeconds.toFixed(2) + 's';

  startBtn.addEventListener('click', startGame);
  resetBtn.addEventListener('click', hardReset);

  // ====== è£œåŠ©é–¢æ•° ======
  function randInt(n){ return Math.floor(Math.random()*n); }
  function pickEndpointExceptCenter(){
    while(true){
      const i = randInt(points), j = randInt(points);
      if(!(i===centerIndex && j===centerIndex)) return {i,j};
    }
  }
  function endpointsEqual(p,q){ return p.i===q.i && p.j===q.j; }
  function endpointOpposite(a,b){
    const dax = a.i - centerIndex, day = a.j - centerIndex;
    const dbx = b.i - centerIndex, dby = b.j - centerIndex;
    return (dax + dbx === 0 && day + dby === 0);
  }

  // ãƒ©ã‚¦ãƒ³ãƒ‰ç”Ÿæˆï¼šA,B ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã€C = âˆ’(A+B)
  function generateRound(){
    let A, B, C;
    let safety = 0;
    do{
      safety++;
      A = pickEndpointExceptCenter();
      do{
        B = pickEndpointExceptCenter();
      } while(endpointsEqual(A,B) || endpointOpposite(A,B));
      const dxA = A.i - centerIndex, dyA = A.j - centerIndex;
      const dxB = B.i - centerIndex, dyB = B.j - centerIndex;
      const dxC = -(dxA + dxB), dyC = -(dyA + dyB);
      C = { i: centerIndex + dxC, j: centerIndex + dyC };
      const inBounds = (C.i>=0 && C.i<points && C.j>=0 && C.j<points);
      const notCenter = !(C.i===centerIndex && C.j===centerIndex);
      const distinct = !endpointsEqual(C,A) && !endpointsEqual(C,B);
      if(inBounds && notCenter && distinct) break;
    } while(safety<999);

    forces = {A,B,C};
    lastAnswer = null;
    revealCorrect = false;
    awaitingAnswer = true;
  }

  // ====== æç”» ======
  function drawGrid(){
    const s = spacing();
    ctx.save();
    ctx.lineWidth = Math.max(1, canvas.width/900);
    ctx.strokeStyle = '#1f2635';
    ctx.strokeRect(margin, margin, s*gridSquares, s*gridSquares);

    ctx.strokeStyle = '#20293a';
    for(let i=0;i<=gridSquares;i++){
      const x = margin + i*s, y = margin + i*s;
      ctx.beginPath(); ctx.moveTo(x, margin); ctx.lineTo(x, margin+s*gridSquares); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(margin, y); ctx.lineTo(margin+s*gridSquares, y); ctx.stroke();
    }

    ctx.fillStyle = '#2a3347';
    for(let i=0;i<points;i++){
      for(let j=0;j<points;j++){
        const {x,y} = ijToXY(i,j);
        ctx.beginPath();
        ctx.arc(x,y, Math.max(2, s*0.04), 0, Math.PI*2);
        ctx.fill();
      }
    }
    ctx.restore();
  }

  // â˜…ä¸­å¤®ã®çƒï¼šä¸é€æ˜å¯„ã‚Šï¼ˆalpha 0.95ï¼‰ï¼‹ã‚°ãƒ­ãƒ¼ã§å¼·èª¿
  function drawCenterBody(){
    const {x,y} = ijToXY(centerIndex, centerIndex);
    const r = Math.max(10, spacing()*0.18);   // ã‚„ã‚„å¤§ãã‚
    ctx.save();
    ctx.globalAlpha = 0.95;                   // é€æ˜åº¦ã‚’ä¸‹ã’ï¼ˆ=ä¸é€æ˜å¯„ã‚Šã«ï¼‰
    const grad = ctx.createRadialGradient(x,y,r*0.15, x,y,r);
    grad.addColorStop(0, '#3a4a6b');
    grad.addColorStop(0.55, '#23304a');
    grad.addColorStop(1, '#101722');
    ctx.fillStyle = grad;

    // å¤–å´ã‚°ãƒ­ãƒ¼
    ctx.shadowColor = 'rgba(120,170,255,0.45)';
    ctx.shadowBlur = Math.max(8, r*0.8);
    ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0;

    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();

    // ã‚¨ãƒƒã‚¸å¼·èª¿ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ï¼ˆäºŒé‡ï¼‰
    ctx.shadowBlur = 0;
    ctx.lineWidth = Math.max(2, r*0.14);
    ctx.strokeStyle = 'rgba(130,180,255,0.55)';
    ctx.stroke();
    ctx.lineWidth = Math.max(1, r*0.06);
    ctx.strokeStyle = '#2e3a52';
    ctx.stroke();

    ctx.restore();
  }

  function drawArrow(from, to, color='#69b7ff', lineDash=null){
    const head = Math.max(8, spacing()*0.22);
    const shaft = Math.max(2, spacing()*0.06);
    ctx.save();
    if(lineDash) ctx.setLineDash(lineDash);
    ctx.lineWidth = shaft;
    ctx.strokeStyle = color;
    ctx.fillStyle = color;

    ctx.beginPath(); ctx.moveTo(from.x, from.y); ctx.lineTo(to.x, to.y); ctx.stroke();

    const dx = to.x - from.x, dy = to.y - from.y;
    const len = Math.hypot(dx,dy);
    if(len > 0.0001){
      const ux = dx/len, uy = dy/len;
      const hx = to.x - ux * head;
      const hy = to.y - uy * head;
      const wing = head * 0.55;
      ctx.beginPath();
      ctx.moveTo(to.x, to.y);
      ctx.lineTo(hx - uy*wing, hy + ux*wing);
      ctx.lineTo(hx + uy*wing, hy - ux*wing);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();
  }

  function drawHoverSnapCircle(i,j){
    const {x,y} = ijToXY(i,j);
    ctx.save();
    ctx.strokeStyle = '#3a4761';
    ctx.lineWidth = Math.max(1, spacing()*0.04);
    ctx.beginPath();
    ctx.arc(x, y, Math.max(10, spacing()*0.22), 0, Math.PI*2);
    ctx.stroke();
    ctx.restore();
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawGrid();
    drawCenterBody();

    const O = ijToXY(centerIndex, centerIndex);

    if(forces){
      // è¡¨ç¤ºä¸­ã®2ãƒ™ã‚¯ãƒˆãƒ«
      const Axy = ijToXY(forces.A.i, forces.A.j);
      const Bxy = ijToXY(forces.B.i, forces.B.j);
      drawArrow(O, Axy, '#69b7ff');
      drawArrow(O, Bxy, '#7dffa7');

      // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®ä»®è¡¨ç¤º
      if(dragging && dragPos){
        drawArrow(O, dragPos, '#c59eff', [8,6]);
        const snapped = xyToIJ(dragPos.x, dragPos.y);
        if(!(snapped.i===centerIndex && snapped.j===centerIndex)){
          drawHoverSnapCircle(snapped.i, snapped.j);
        }
      }

      // æå‡ºæ¸ˆã¿ã®è§£ç­”
      if(lastAnswer){
        const Ans = ijToXY(lastAnswer.i, lastAnswer.j);
        drawArrow(O, Ans, '#c59eff', [8,6]);
      }

      // æ­£è§£ã®å¯è¦–åŒ–
      if(revealCorrect){
        const Cxy = ijToXY(forces.C.i, forces.C.j);
        drawArrow(O, Cxy, '#ffd166');
      }
    }
  }

  // ====== ã‚¿ã‚¤ãƒãƒ¼ ======
  function startTimer(){
    stopTimer();
    timerId = setInterval(() => {
      if(!playing) return;
      const t = elapsedSeconds();
      timeLabel.textContent = t.toFixed(2) + 's';
      if(t > maxSeconds && !gameOverFlag){
        gameOver(`æ™‚é–“åˆ‡ã‚Œâ€¦ ${maxSeconds.toFixed(0)}ç§’ä»¥å†…ã«5é€£ç¶šæ­£è§£ãŒå¿…è¦ã§ã™ã€‚`);
      }
    }, 30);
  }
  function stopTimer(){ if(timerId){ clearInterval(timerId); timerId = null; } }
  function elapsedSeconds(){ return startTime ? (performance.now() - startTime)/1000 : 0; }

  // ====== é€²è¡Œç®¡ç† ======
  function startGame(){
    playing = true;
    gameOverFlag = false;
    round = 0;
    startTime = performance.now();
    startBtn.disabled = true;
    resetBtn.disabled = false;
    nextRound();
    startTimer();
    announce('ã‚¹ã‚¿ãƒ¼ãƒˆï¼ ä¸­å¤®ã‹ã‚‰ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦çŸ¢å°ã‚’å¼•ãã€é›¢ã™ã¨æœ€è¿‘å‚ã®äº¤ç‚¹ã«ã‚¹ãƒŠãƒƒãƒ—ã—ã¾ã™ã€‚');
  }
  function nextRound(){
    round++;
    if(round > totalRounds){ finishGame(); return; }
    roundLabel.textContent = `${round} / ${totalRounds}`;
    generateRound();
    draw();
  }
  function finishGame(){
    playing = false;
    awaitingAnswer = false;
    revealCorrect = true;
    stopTimer();
    const t = elapsedSeconds();
    draw();
    if(t <= maxSeconds){
      announce(`ã‚¯ãƒªã‚¢ï¼ 5å›é€£ç¶šæ­£è§£ã€‚è¨˜éŒ²ï¼š${t.toFixed(2)}ç§’ï¼ˆ${maxSeconds.toFixed(0)}ç§’ä»¥å†…é”æˆï¼‰ğŸ‰`);
    }else{
      announce(`5å›é€£ç¶šæ­£è§£ï¼ ã§ã‚‚ ${t.toFixed(2)}ç§’ ã§åˆ¶é™è¶…éâ€¦ æƒœã—ã„ï¼ã‚‚ã†ä¸€åº¦æŒ‘æˆ¦ã—ã¦ã­ã€‚`);
    }
    startBtn.disabled = false;
    startBtn.textContent = 'ã‚‚ã†ä¸€åº¦';
  }
  function gameOver(reason='ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼'){
    playing = false;
    awaitingAnswer = false;
    gameOverFlag = true;
    revealCorrect = true;
    stopTimer();
    draw();
    announce(`âŒ ${reason}`);
    startBtn.disabled = false;
    startBtn.textContent = 'ãƒªãƒˆãƒ©ã‚¤';
  }
  function hardReset(){
    playing = false;
    awaitingAnswer = false;
    gameOverFlag = false;
    revealCorrect = false;
    lastAnswer = null;
    forces = null;
    round = 0;
    startTime = null;
    dragging = false;
    dragPos = null;
    timeLabel.textContent = '0.00s';
    roundLabel.textContent = '0 / 5';
    startBtn.disabled = false;
    startBtn.textContent = 'ã‚¹ã‚¿ãƒ¼ãƒˆ';
    announce('[æ“ä½œ] ä¸­å¤®ã‹ã‚‰ãƒ‰ãƒ©ãƒƒã‚°ã§çŸ¢å°ã‚’ä½œå›³ã€‚é›¢ã™ã¨æœ€è¿‘å‚ã®äº¤ç‚¹ã¸ã‚¹ãƒŠãƒƒãƒ—ã—ã¾ã™ï¼ˆä¸­å¤®ã¯ä¸å¯ï¼‰ã€‚');
    fitCanvasDPI();
    draw();
  }

  function announce(text){ msgEl.innerHTML = text.replace(/\n/g,'<br/>'); }

  // ====== å…¥åŠ›ï¼šPointer Events ======
  function getCanvasXYFromEvent(e){
    const rect = canvas.getBoundingClientRect();
    const px = (e.clientX - rect.left) * (canvas.width / rect.width);
    const py = (e.clientY - rect.top)  * (canvas.height / rect.height);
    return {x:px, y:py};
  }

  function pointerDown(e){
    if(!playing || !awaitingAnswer || !forces) return;
    const pos = getCanvasXYFromEvent(e);
    const O = ijToXY(centerIndex, centerIndex);
    const r = Math.max(10, spacing()*startFromCenterRadiusFactor);
    if(Math.hypot(pos.x - O.x, pos.y - O.y) <= r * 2.0){
      dragging = true;
      dragPos = pos;
      canvas.setPointerCapture?.(e.pointerId);
      e.preventDefault();
      draw();
    }
  }
  function pointerMove(e){
    if(!dragging) return;
    dragPos = getCanvasXYFromEvent(e);
    draw();
  }
  function pointerUp(e){
    if(!dragging) return;
    dragging = false;
    const pos = getCanvasXYFromEvent(e);
    const {i,j} = xyToIJ(pos.x, pos.y);
    if(i===centerIndex && j===centerIndex){
      announce('ä¸­å¤®ï¼ˆç‰©ä½“ä½ç½®ï¼‰ã¯çµ‚ç‚¹ã«ã§ãã¾ã›ã‚“ã€‚ã‚‚ã†ä¸€åº¦ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ã­ã€‚');
      dragPos = null; draw(); return;
    }
    lastAnswer = {i,j};
    dragPos = null; draw();

    const correct = (i===forces.C.i && j===forces.C.j);
    if(correct){
      awaitingAnswer = false;
      revealCorrect = true; draw();
      announce('âœ… æ­£è§£ï¼ æ¬¡ã®ãƒ©ã‚¦ãƒ³ãƒ‰ã¸â€¦');
      setTimeout(() => { revealCorrect = false; nextRound(); }, 450);
    }else{
      revealCorrect = true; draw();
      gameOver('ãƒ™ã‚¯ãƒˆãƒ«ãŒã¤ã‚Šåˆã„ã¾ã›ã‚“ï¼ˆä¸æ­£è§£ï¼‰ã€‚');
    }
  }

  canvas.addEventListener('pointerdown', pointerDown, {passive:false});
  canvas.addEventListener('pointermove',  pointerMove, {passive:false});
  canvas.addEventListener('pointerup',    pointerUp,   {passive:false});
  canvas.addEventListener('pointercancel', () => { dragging = false; dragPos = null; draw(); });

  // ã‚¿ãƒƒãƒã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æŠ‘æ­¢ï¼ˆã‚­ãƒ£ãƒ³ãƒã‚¹ä¸Šã®ã¿ï¼‰
  canvas.addEventListener('touchstart', (e)=>e.preventDefault(), {passive:false});
  canvas.addEventListener('touchmove',  (e)=>e.preventDefault(), {passive:false});
})();
</script>
</body>
</html>