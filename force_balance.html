<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>力のつり合いゲーム〜力を加えてつり合わせろ！〜</title>
<style>
  :root {
    --bg:#0f1117; --panel:#161a22; --ink:#e6edf3; --muted:#9aa4b2;
    --accent:#5dd4ff; --accent2:#9b8cff; --ok:#2ecc71; --warn:#ffd166; --danger:#ff6b6b;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Noto Sans JP,sans-serif;}
  .wrap{max-width:980px;margin:24px auto;padding:0 16px;}
  header{display:flex;gap:12px;align-items:center;justify-content:space-between;margin-bottom:12px;flex-wrap:wrap}
  h1{font-size:20px;margin:0;font-weight:700;letter-spacing:.02em}
  .hud{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  .pill{padding:6px 10px;border-radius:999px;background:var(--panel);color:var(--ink);border:1px solid #222836}
  .pill b{font-variant-numeric:tabular-nums}
  button{all:unset;cursor:pointer;padding:10px 14px;border-radius:10px;background:linear-gradient(180deg,#1c2331,#141923);border:1px solid #1e2432;transition:.15s}
  button:hover{filter:brightness(1.05)}
  button:disabled{opacity:.5;cursor:not-allowed}
  .btn-toggle[aria-pressed="true"]{background:linear-gradient(180deg,#1f2740,#141923);border-color:#2e3a52;box-shadow:0 0 0 2px rgba(93,212,255,.15) inset}
  #canvasBox{background:var(--panel);border:1px solid #1e2432;border-radius:16px;padding:12px}
  #canvas{width:100%;height:auto;display:block;background:linear-gradient(180deg,#151a23,#131722);border-radius:12px}
  .msg{margin-top:10px;min-height:28px;color:var(--muted)}
  .legend{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-top:8px;color:var(--muted);font-size:14px}
  .chip{display:inline-flex;gap:6px;align-items:center;padding:4px 8px;border-radius:999px;background:#121722;border:1px solid #252c3b}
  .dot{width:12px;height:12px;border-radius:50%}
  .c-blue{background:#69b7ff}
  .c-green{background:#7dffa7}
  .c-purple{background:#c59eff}
  .c-yellow{background:#ffd166}
  .c-gray{background:#a4b0c6}
  .footer{margin-top:16px;color:var(--muted);font-size:14px}
  .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace;background:#0e1220;padding:2px 6px;border:1px solid #242a3a;border-radius:6px}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>力のつり合いゲーム〜力を加えてつり合わせろ！〜</h1>
    <div class="hud">
      <div class="pill">スコア：<b id="scoreLabel">0</b></div>
      <div class="pill">残り：<b id="timeLabel">60.00s</b></div>
      <div class="pill">ルール：<b>1分で何問？（正:+1／誤:-1）</b></div>
      <button id="assistBtn" class="btn-toggle" aria-pressed="false" title="補助線を引くモードを切替">補助線を引く</button>
      <button id="startBtn">スタート</button>
      <button id="resetBtn" disabled>リセット</button>
    </div>
  </header>

  <div id="canvasBox">
    <canvas id="canvas" width="720" height="720"></canvas>
    <div class="legend">
      <span class="chip"><span class="dot c-blue"></span>表示中の力①</span>
      <span class="chip"><span class="dot c-green"></span>表示中の力②</span>
      <span class="chip"><span class="dot c-purple"></span>あなたの解答（ドラッグ中/提出済）</span>
      <span class="chip"><span class="dot c-yellow"></span>正解（ラウンド終了時のみ）</span>
      <span class="chip"><span class="dot c-gray"></span>補助線（トグルONで破線）</span>
      <span class="chip">8×8マス（交点は9×9）／中央の交点に物体</span>
    </div>
    <div class="msg" id="msg">[操作] スタート後、中央からドラッグして矢印を引き、離すと最近傍の交点にスナップ。補助線は問題が切替わるたびに消えます。</div>
  </div>

  <div class="footer">
    ヒント：3つの力のベクトル和は <span class="kbd">0</span>。表示の2本 <span class="kbd">F₁</span>, <span class="kbd">F₂</span> に対して欠けた力は <span class="kbd">F₃ = −(F₁ + F₂)</span>。
  </div>
</div>

<script>
(() => {
  // ====== 基本設定 ======
  const gridSquares = 8;                   // 8×8マス
  const points = gridSquares + 1;          // 交点は 9 × 9
  const centerIndex = Math.floor(points/2);
  const margin = 28;
  const gameSeconds = 60.0;                // 1分勝負
  const revealDelayMs = 400;               // 正解表示の短いディレイ

  // ====== キャンバス調整 ======
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  function fitCanvasDPI(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const box = canvas.parentElement || document.body;
    const boxRect = box.getBoundingClientRect();
    const remainH = Math.max(220, window.innerHeight - boxRect.top - 24);
    const availW  = box.clientWidth || boxRect.width;
    const cssSize = Math.max(200, Math.floor(Math.min(availW, remainH)));
    const size = Math.floor(cssSize * dpr);
    canvas.width = size; canvas.height = size;
    canvas.style.width = (size/dpr) + 'px';
    canvas.style.height = (size/dpr) + 'px';
  }
  requestAnimationFrame(() => { fitCanvasDPI(); draw(); });
  window.addEventListener('resize', () => { fitCanvasDPI(); draw(); });
  window.addEventListener('orientationchange', () => setTimeout(()=>{ fitCanvasDPI(); draw(); }, 60));

  // 座標変換
  function spacing(){ return (Math.min(canvas.width, canvas.height) - margin*2) / gridSquares; }
  function ijToXY(i,j){ const s = spacing(); return { x: margin + i*s, y: margin + j*s }; }
  function xyToIJ(x,y){
    const s = spacing();
    let i = Math.round((x - margin) / s);
    let j = Math.round((y - margin) / s);
    i = Math.max(0, Math.min(points-1, i));
    j = Math.max(0, Math.min(points-1, j));
    return {i,j};
  }

  // ====== 状態 ======
  let score = 0;
  let startTime = null;
  let timerId = null;
  let playing = false;
  let awaitingAnswer = false;
  let forces = null;       // {A,B,C}
  let lastAnswer = null;
  let revealCorrect = false;

  // 解答ドラッグ
  let dragging = false;
  let dragPos = null;      // {x,y}
  const startFromCenterRadiusFactor = 0.5;

  // 補助線モード
  let assistMode = false;
  let assistDragging = false;
  let assistStart = null;     // {i,j}
  let assistTempEnd = null;   // {x,y}
  const assistLines = [];     // [{a:{i,j}, b:{i,j}}]

  // UI
  const msgEl = document.getElementById('msg');
  const scoreLabel = document.getElementById('scoreLabel');
  const timeLabel  = document.getElementById('timeLabel');
  const startBtn   = document.getElementById('startBtn');
  const resetBtn   = document.getElementById('resetBtn');
  const assistBtn  = document.getElementById('assistBtn');

  startBtn.addEventListener('click', startGame);
  resetBtn.addEventListener('click', hardReset);
  assistBtn.addEventListener('click', toggleAssist);

  // ====== ユーティリティ ======
  function randInt(n){ return Math.floor(Math.random()*n); }
  function pickEndpointExceptCenter(){
    while(true){
      const i = randInt(points), j = randInt(points);
      if(!(i===centerIndex && j===centerIndex)) return {i,j};
    }
  }
  function endpointsEqual(p,q){ return p.i===q.i && p.j===q.j; }
  function endpointOpposite(a,b){
    const dax = a.i - centerIndex, day = a.j - centerIndex;
    const dbx = b.i - centerIndex, dby = b.j - centerIndex;
    return (dax + dbx === 0 && day + dby === 0);
  }

  // 出題生成
  function generateRound(){
    let A, B, C;
    let safety = 0;
    do{
      safety++;
      A = pickEndpointExceptCenter();
      do{
        B = pickEndpointExceptCenter();
      } while(endpointsEqual(A,B) || endpointOpposite(A,B));
      const dxA = A.i - centerIndex, dyA = A.j - centerIndex;
      const dxB = B.i - centerIndex, dyB = B.j - centerIndex;
      const dxC = -(dxA + dxB), dyC = -(dyA + dyB);
      C = { i: centerIndex + dxC, j: centerIndex + dyC };
      const inBounds = (C.i>=0 && C.i<points && C.j>=0 && C.j<points);
      const notCenter = !(C.i===centerIndex && C.j===centerIndex);
      const distinct = !endpointsEqual(C,A) && !endpointsEqual(C,B);
      if(inBounds && notCenter && distinct) break;
    } while(safety<999);

    forces = {A,B,C};
    lastAnswer = null;
    revealCorrect = false;
    awaitingAnswer = true;
  }

  // ★ 出題切替（ここで補助線を全消去）
  function nextRound(){
    assistLines.length = 0;          // 要望：問題切替で補助線全消し
    assistDragging = false;
    assistStart = null;
    assistTempEnd = null;
    generateRound();
    draw();
  }

  // ====== 描画 ======
  function drawGrid(){
    const s = spacing();
    ctx.save();
    ctx.lineWidth = Math.max(1, canvas.width/900);
    ctx.strokeStyle = '#1f2635';
    ctx.strokeRect(margin, margin, s*gridSquares, s*gridSquares);

    ctx.strokeStyle = '#20293a';
    for(let i=0;i<=gridSquares;i++){
      const x = margin + i*s, y = margin + i*s;
      ctx.beginPath(); ctx.moveTo(x, margin); ctx.lineTo(x, margin+s*gridSquares); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(margin, y); ctx.lineTo(margin+s*gridSquares, y); ctx.stroke();
    }

    ctx.fillStyle = '#2a3347';
    for(let i=0;i<points;i++){
      for(let j=0;j<points;j++){
        const {x,y} = ijToXY(i,j);
        ctx.beginPath();
        ctx.arc(x,y, Math.max(2, s*0.04), 0, Math.PI*2);
        ctx.fill();
      }
    }
    ctx.restore();
  }

  function drawCenterBody(){
    const {x,y} = ijToXY(centerIndex, centerIndex);
    const r = Math.max(10, spacing()*0.18);
    ctx.save();
    ctx.globalAlpha = 0.95;
    const grad = ctx.createRadialGradient(x,y,r*0.15, x,y,r);
    grad.addColorStop(0, '#3a4a6b');
    grad.addColorStop(0.55, '#23304a');
    grad.addColorStop(1, '#101722');
    ctx.fillStyle = grad;
    ctx.shadowColor = 'rgba(120,170,255,0.45)';
    ctx.shadowBlur = Math.max(8, r*0.8);
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
    ctx.shadowBlur = 0;
    ctx.lineWidth = Math.max(2, r*0.14);
    ctx.strokeStyle = 'rgba(130,180,255,0.55)'; ctx.stroke();
    ctx.lineWidth = Math.max(1, r*0.06);
    ctx.strokeStyle = '#2e3a52'; ctx.stroke();
    ctx.restore();
  }

  function drawArrow(from, to, color='#69b7ff', lineDash=null){
    const head = Math.max(8, spacing()*0.22);
    const shaft = Math.max(2, spacing()*0.06);
    ctx.save();
    if(lineDash) ctx.setLineDash(lineDash);
    ctx.lineWidth = shaft;
    ctx.strokeStyle = color;
    ctx.fillStyle = color;

    ctx.beginPath(); ctx.moveTo(from.x, from.y); ctx.lineTo(to.x, to.y); ctx.stroke();

    const dx = to.x - from.x, dy = to.y - from.y;
    const len = Math.hypot(dx,dy);
    if(len > 0.0001){
      const ux = dx/len, uy = dy/len;
      const hx = to.x - ux * head;
      const hy = to.y - uy * head;
      const wing = head * 0.55;
      ctx.beginPath();
      ctx.moveTo(to.x, to.y);
      ctx.lineTo(hx - uy*wing, hy + ux*wing);
      ctx.lineTo(hx + uy*wing, hy - ux*wing);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();
  }

  function drawAssistLine(aIJ, bIJ, temp=false){
    const A = ijToXY(aIJ.i, aIJ.j);
    const B = temp ? bIJ : ijToXY(bIJ.i, bIJ.j);
    ctx.save();
    ctx.setLineDash([6,6]);
    ctx.lineWidth = Math.max(1.5, spacing()*0.05);
    ctx.strokeStyle = '#a4b0c6';
    ctx.beginPath(); ctx.moveTo(A.x, A.y); ctx.lineTo(B.x, B.y); ctx.stroke();
    ctx.restore();
  }

  function drawHoverSnapCircle(i,j){
    const {x,y} = ijToXY(i,j);
    ctx.save();
    ctx.strokeStyle = '#3a4761';
    ctx.lineWidth = Math.max(1, spacing()*0.04);
    ctx.beginPath();
    ctx.arc(x, y, Math.max(10, spacing()*0.22), 0, Math.PI*2);
    ctx.stroke();
    ctx.restore();
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawGrid();

    // 補助線（確定済み）
    for(const seg of assistLines){ drawAssistLine(seg.a, seg.b, false); }

    drawCenterBody();

    const O = ijToXY(centerIndex, centerIndex);

    if(forces){
      const Axy = ijToXY(forces.A.i, forces.A.j);
      const Bxy = ijToXY(forces.B.i, forces.B.j);
      drawArrow(O, Axy, '#69b7ff');
      drawArrow(O, Bxy, '#7dffa7');

      // 解答ドラッグ中
      if(dragging && dragPos){
        drawArrow(O, dragPos, '#c59eff', [8,6]);
        const snapped = xyToIJ(dragPos.x, dragPos.y);
        if(!(snapped.i===centerIndex && snapped.j===centerIndex)){ drawHoverSnapCircle(snapped.i, snapped.j); }
      }

      // 補助線ドラッグ中
      if(assistDragging && assistStart && assistTempEnd){
        drawAssistLine(assistStart, assistTempEnd, true);
        const snap = xyToIJ(assistTempEnd.x, assistTempEnd.y);
        drawHoverSnapCircle(snap.i, snap.j);
      }

      // 提出済み
      if(lastAnswer){
        const Ans = ijToXY(lastAnswer.i, lastAnswer.j);
        drawArrow(O, Ans, '#c59eff', [8,6]);
      }

      // 正解の可視化
      if(revealCorrect){
        const Cxy = ijToXY(forces.C.i, forces.C.j);
        drawArrow(O, Cxy, '#ffd166');
      }
    }
  }

  // ====== タイマー ======
  function startTimer(){
    stopTimer();
    timerId = setInterval(() => {
      if(!playing) return;
      const remain = remainingSeconds();
      timeLabel.textContent = Math.max(0, remain).toFixed(2) + 's';
      if(remain <= 0){ finishGame(); }
    }, 30);
  }
  function stopTimer(){ if(timerId){ clearInterval(timerId); timerId = null; } }
  function remainingSeconds(){
    if(!startTime) return gameSeconds;
    const elapsed = (performance.now() - startTime) / 1000;
    return gameSeconds - elapsed;
  }

  // ====== 進行 ======
  function startGame(){
    score = 0; updateScore(0,true);
    startTime = performance.now();
    playing = true;
    startBtn.disabled = true; resetBtn.disabled = false;
    nextRound();                        // ← 出題時に補助線クリア
    startTimer();
    announce('スタート！ 正解+1／不正解-1。60秒でハイスコアを狙おう。');
  }
  function finishGame(){
    playing = false; awaitingAnswer = false; revealCorrect = false;
    stopTimer(); draw();
    announce(`終了！ スコア：${score} 点（正:+1／誤:-1）。もう一度挑戦する？`);
    startBtn.disabled = false; startBtn.textContent = 'もう一度';
  }
  function updateScore(delta, force=false){
    if(!force) score += delta;
    scoreLabel.textContent = String(score);
  }

  function hardReset(){
    playing = false; awaitingAnswer = false; revealCorrect = false;
    stopTimer();
    score = 0; startTime = null;
    lastAnswer = null; forces = null;
    dragging = false; dragPos = null;
    assistMode = false; assistBtn.setAttribute('aria-pressed','false'); assistBtn.textContent = '補助線を引く';
    assistDragging = false; assistStart = null; assistTempEnd = null; assistLines.length = 0;
    timeLabel.textContent = gameSeconds.toFixed(2)+'s';
    scoreLabel.textContent = '0';
    startBtn.disabled = false; startBtn.textContent = 'スタート';
    announce('[操作] 中央からドラッグで解答。補助線は出題切替で自動消去。補助線ボタンでON/OFF切替。');
    fitCanvasDPI(); draw();
  }

  function announce(text){ msgEl.innerHTML = text.replace(/\n/g,'<br/>'); }

  // ====== 補助線モード ======
  function toggleAssist(){
    assistMode = !assistMode;
    assistBtn.setAttribute('aria-pressed', String(assistMode));
    assistBtn.textContent = assistMode ? '補助線モード中（もう一度で解除）' : '補助線を引く';
    announce(assistMode ? '補助線モードON：格子点から格子点へドラッグで破線を引けます。' : '補助線モードOFF。');
  }

  // ====== 入力：Pointer Events ======
  function getCanvasXYFromEvent(e){
    const rect = canvas.getBoundingClientRect();
    const px = (e.clientX - rect.left) * (canvas.width / rect.width);
    const py = (e.clientY - rect.top)  * (canvas.height / rect.height);
    return {x:px, y:py};
  }

  function pointerDown(e){
    const pos = getCanvasXYFromEvent(e);

    // 補助線モード
    if(assistMode){
      const startIJ = xyToIJ(pos.x, pos.y);
      assistDragging = true;
      assistStart = startIJ;
      assistTempEnd = pos;
      canvas.setPointerCapture?.(e.pointerId);
      e.preventDefault(); draw(); return;
    }

    // 解答ドラッグ（中央近傍からのみ）
    if(!playing || !forces) return;
    const O = ijToXY(centerIndex, centerIndex);
    const r = Math.max(10, spacing()*startFromCenterRadiusFactor);
    if(Math.hypot(pos.x - O.x, pos.y - O.y) <= r * 2.0){
      dragging = true; dragPos = pos;
      canvas.setPointerCapture?.(e.pointerId);
      e.preventDefault(); draw();
    }
  }

  function pointerMove(e){
    const pos = getCanvasXYFromEvent(e);

    if(assistMode){
      if(!assistDragging) return;
      assistTempEnd = pos; draw(); return;
    }

    if(!dragging) return;
    dragPos = pos; draw();
  }

  function pointerUp(e){
    const pos = getCanvasXYFromEvent(e);

    if(assistMode){
      if(!assistDragging) return;
      assistDragging = false;
      const endIJ = xyToIJ(pos.x, pos.y);
      if(!(assistStart.i===endIJ.i && assistStart.j===endIJ.j)){
        assistLines.push({a:{...assistStart}, b:{...endIJ}});
      }
      assistStart = null; assistTempEnd = null; draw(); return;
    }

    if(!dragging) return;
    dragging = false;

    if(!playing || !awaitingAnswer || !forces){ dragPos = null; draw(); return; }

    // 解答スナップ
    const {i,j} = xyToIJ(pos.x, pos.y);
    if(i===centerIndex && j===centerIndex){
      announce('中央（物体位置）は終点にできません。もう一度ドラッグしてね。');
      dragPos = null; draw(); return;
    }
    lastAnswer = {i,j};
    dragPos = null; draw();

    // 判定 → 正解+1／不正解-1
    const correct = (i===forces.C.i && j===forces.C.j);
    updateScore(correct ? +1 : -1);
    revealCorrect = true; draw();

    // 短く見せて次問題（ここで補助線クリアも行われる）
    setTimeout(() => {
      revealCorrect = false; awaitingAnswer = true;
      nextRound(); // ← 出題切替で補助線全削除
    }, revealDelayMs);
  }

  canvas.addEventListener('pointerdown', pointerDown, {passive:false});
  canvas.addEventListener('pointermove',  pointerMove,  {passive:false});
  canvas.addEventListener('pointerup',    pointerUp,    {passive:false});
  canvas.addEventListener('pointercancel', () => {
    dragging = false; dragPos = null;
    assistDragging = false; assistTempEnd = null;
    draw();
  });

  // タッチスクロール抑止（キャンバス上のみ）
  canvas.addEventListener('touchstart', (e)=>e.preventDefault(), {passive:false});
  canvas.addEventListener('touchmove',  (e)=>e.preventDefault(), {passive:false});
})();
</script>
</body>
</html>
