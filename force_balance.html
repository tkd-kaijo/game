<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>åŠ›ã®ã¤ã‚Šåˆã„ã‚²ãƒ¼ãƒ ã€œåŠ›ã‚’åŠ ãˆã¦ã¤ã‚Šåˆã‚ã›ã‚ï¼ã€œ</title>
<style>
  :root {
    --bg:#0f1117; --panel:#161a22; --ink:#e6edf3; --muted:#9aa4b2;
    --accent:#5dd4ff; --accent2:#9b8cff; --ok:#2ecc71; --warn:#ffd166; --danger:#ff6b6b;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Noto Sans JP,sans-serif;}
  .wrap{max-width:980px;margin:24px auto;padding:0 16px;}
  header{display:flex;gap:12px;align-items:center;justify-content:space-between;margin-bottom:12px;flex-wrap:wrap}
  h1{font-size:20px;margin:0;font-weight:700;letter-spacing:.02em}
  .hud{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  .pill{padding:6px 10px;border-radius:999px;background:var(--panel);color:var(--ink);border:1px solid #222836}
  .pill b{font-variant-numeric:tabular-nums}
  button{all:unset;cursor:pointer;padding:10px 14px;border-radius:10px;background:linear-gradient(180deg,#1c2331,#141923);border:1px solid #1e2432;transition:.15s}
  button:hover{filter:brightness(1.05)}
  button:disabled{opacity:.5;cursor:not-allowed}
  .btn-toggle[aria-pressed="true"]{background:linear-gradient(180deg,#1f2740,#141923);border-color:#2e3a52;box-shadow:0 0 0 2px rgba(93,212,255,.15) inset}
  #canvasBox{background:var(--panel);border:1px solid #1e2432;border-radius:16px;padding:12px}
  #canvas{width:100%;height:auto;display:block;background:linear-gradient(180deg,#151a23,#131722);border-radius:12px}
  .msg{margin-top:10px;min-height:28px;color:var(--muted)}
  .legend{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-top:8px;color:var(--muted);font-size:14px}
  .chip{display:inline-flex;gap:6px;align-items:center;padding:4px 8px;border-radius:999px;background:#121722;border:1px solid #252c3b}
  .dot{width:12px;height:12px;border-radius:50%}
  .c-blue{background:#69b7ff}
  .c-green{background:#7dffa7}
  .c-purple{background:#c59eff}
  .c-yellow{background:#ffd166}
  .c-gray{background:#a4b0c6}
  .footer{margin-top:16px;color:var(--muted);font-size:14px}
  .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace;background:#0e1220;padding:2px 6px;border:1px solid #242a3a;border-radius:6px}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>åŠ›ã®ã¤ã‚Šåˆã„ã‚²ãƒ¼ãƒ ã€œåŠ›ã‚’åŠ ãˆã¦ã¤ã‚Šåˆã‚ã›ã‚ï¼ã€œ</h1>
    <div class="hud">
      <div class="pill">ã‚¹ã‚³ã‚¢ï¼š<b id="scoreLabel">0</b></div>
      <div class="pill">æ®‹ã‚Šï¼š<b id="timeLabel">60.00s</b></div>
      <div class="pill">ãƒ«ãƒ¼ãƒ«ï¼š<b>1åˆ†é–“ã§æ­£è§£æ•°ã‚’ç«¶ã†</b></div>
      <button id="assistBtn" class="btn-toggle" aria-pressed="false" title="è£œåŠ©ç·šã‚’å¼•ããƒ¢ãƒ¼ãƒ‰ã‚’åˆ‡æ›¿">è£œåŠ©ç·šã‚’å¼•ã</button>
      <button id="startBtn">ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
      <button id="resetBtn" disabled>ãƒªã‚»ãƒƒãƒˆ</button>
    </div>
  </header>

  <div id="canvasBox">
    <canvas id="canvas" width="720" height="720"></canvas>
    <div class="legend">
      <span class="chip"><span class="dot c-blue"></span>è¡¨ç¤ºä¸­ã®åŠ›â‘ </span>
      <span class="chip"><span class="dot c-green"></span>è¡¨ç¤ºä¸­ã®åŠ›â‘¡</span>
      <span class="chip"><span class="dot c-purple"></span>ã‚ãªãŸã®è§£ç­”ï¼ˆãƒ‰ãƒ©ãƒƒã‚°ä¸­/æå‡ºæ¸ˆï¼‰</span>
      <span class="chip"><span class="dot c-yellow"></span>æ­£è§£ï¼ˆãƒ©ã‚¦ãƒ³ãƒ‰çµ‚äº†æ™‚ã®ã¿ï¼‰</span>
      <span class="chip"><span class="dot c-gray"></span>è£œåŠ©ç·šï¼ˆãƒˆã‚°ãƒ«ONã§è‡ªç”±ã«ç ´ç·šï¼‰</span>
      <span class="chip">8Ã—8ãƒã‚¹ï¼ˆäº¤ç‚¹ã¯9Ã—9ï¼‰ï¼ä¸­å¤®ã®äº¤ç‚¹ã«ç‰©ä½“</span>
    </div>
    <div class="msg" id="msg">[æ“ä½œ] ã‚¹ã‚¿ãƒ¼ãƒˆå¾Œã€ä¸­å¤®ã‹ã‚‰ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦çŸ¢å°ã‚’å¼•ãã€é›¢ã™ã¨æœ€è¿‘å‚ã®äº¤ç‚¹ã«ã‚¹ãƒŠãƒƒãƒ—ã€‚60ç§’ã§ä½•å•è§£ã‘ã‚‹ã‹æŒ‘æˆ¦ï¼ è£œåŠ©ç·šãƒ¢ãƒ¼ãƒ‰ã§ä½œå›³ã®ä¸‹æ›¸ãã‚‚å¯ã€‚</div>
  </div>

  <div class="footer">
    ãƒ’ãƒ³ãƒˆï¼š3ã¤ã®åŠ›ã®ãƒ™ã‚¯ãƒˆãƒ«å’Œã¯ <span class="kbd">0</span>ã€‚è¡¨ç¤ºã®2æœ¬ <span class="kbd">Fâ‚</span>, <span class="kbd">Fâ‚‚</span> ã«å¯¾ã—ã¦æ¬ ã‘ãŸåŠ›ã¯ <span class="kbd">Fâ‚ƒ = âˆ’(Fâ‚ + Fâ‚‚)</span>ã€‚
  </div>
</div>

<script>
(() => {
  // ====== åŸºæœ¬è¨­å®š ======
  const gridSquares = 8;                   // 8Ã—8ãƒã‚¹
  const points = gridSquares + 1;          // äº¤ç‚¹ã¯ 9 Ã— 9
  const centerIndex = Math.floor(points/2);// ä¸­å¤®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆ0åŸºæº–ï¼‰
  const margin = 28;                       // ä½™ç™½ï¼ˆpxï¼‰
  const gameSeconds = 60.0;                // 1åˆ†å‹è² 
  const revealDelayMs = 400;               // æ­£è§£è¡¨ç¤ºã®çŸ­ã„ãƒ‡ã‚£ãƒ¬ã‚¤

  // ====== ã‚­ãƒ£ãƒ³ãƒã‚¹ & DPI è£œæ­£ ======
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  function fitCanvasDPI(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const box = canvas.parentElement || document.body;
    const boxRect = box.getBoundingClientRect();
    const remainH = Math.max(220, window.innerHeight - boxRect.top - 24);
    const availW  = box.clientWidth || boxRect.width;
    const cssSize = Math.max(200, Math.floor(Math.min(availW, remainH)));
    const size = Math.floor(cssSize * dpr);
    canvas.width = size; canvas.height = size;
    canvas.style.width = (size/dpr) + 'px';
    canvas.style.height = (size/dpr) + 'px';
  }
  requestAnimationFrame(() => { fitCanvasDPI(); draw(); });
  window.addEventListener('resize', () => { fitCanvasDPI(); draw(); });
  window.addEventListener('orientationchange', () => setTimeout(()=>{ fitCanvasDPI(); draw(); }, 60));

  // åº§æ¨™å¤‰æ›
  function spacing(){ return (Math.min(canvas.width, canvas.height) - margin*2) / gridSquares; }
  function ijToXY(i,j){ const s = spacing(); return { x: margin + i*s, y: margin + j*s }; }
  function xyToIJ(x,y){
    const s = spacing();
    let i = Math.round((x - margin) / s);
    let j = Math.round((y - margin) / s);
    i = Math.max(0, Math.min(points-1, i));
    j = Math.max(0, Math.min(points-1, j));
    return {i,j};
  }

  // ====== ã‚²ãƒ¼ãƒ çŠ¶æ…‹ ======
  let score = 0;
  let startTime = null;
  let timerId = null;
  let playing = false;
  let awaitingAnswer = false;
  let forces = null;       // {A:{i,j}, B:{i,j}, C:{i,j}}
  let lastAnswer = null;   // æå‡ºæ¸ˆã¿ {i,j}
  let revealCorrect = false;

  // ãƒ‰ãƒ©ãƒƒã‚°å…¥åŠ›çŠ¶æ…‹ï¼ˆè§£ç­”ç”¨ï¼‰
  let dragging = false;
  let dragPos = null;      // {x,y}ï¼ˆã‚­ãƒ£ãƒ³ãƒã‚¹åº§æ¨™ï¼‰
  const startFromCenterRadiusFactor = 0.5; // ä¸­å¤®è¿‘å‚ã‹ã‚‰ã®ã¿é–‹å§‹

  // è£œåŠ©ç·šãƒ¢ãƒ¼ãƒ‰
  let assistMode = false;
  let assistDragging = false;
  let assistStart = null; // {i,j}
  let assistTempEnd = null; // {x,y} ãƒ‰ãƒ©ãƒƒã‚°ä¸­åº§æ¨™
  const assistLines = []; // [{a:{i,j}, b:{i,j}} ...]

  // UI å‚ç…§
  const msgEl = document.getElementById('msg');
  const scoreLabel = document.getElementById('scoreLabel');
  const timeLabel  = document.getElementById('timeLabel');
  const startBtn   = document.getElementById('startBtn');
  const resetBtn   = document.getElementById('resetBtn');
  const assistBtn  = document.getElementById('assistBtn');

  startBtn.addEventListener('click', startGame);
  resetBtn.addEventListener('click', hardReset);
  assistBtn.addEventListener('click', toggleAssist);

  // ====== è£œåŠ©é–¢æ•° ======
  function randInt(n){ return Math.floor(Math.random()*n); }
  function pickEndpointExceptCenter(){
    while(true){
      const i = randInt(points), j = randInt(points);
      if(!(i===centerIndex && j===centerIndex)) return {i,j};
    }
  }
  function endpointsEqual(p,q){ return p.i===q.i && p.j===q.j; }
  function endpointOpposite(a,b){
    const dax = a.i - centerIndex, day = a.j - centerIndex;
    const dbx = b.i - centerIndex, dby = b.j - centerIndex;
    return (dax + dbx === 0 && day + dby === 0);
  }

  // ãƒ©ã‚¦ãƒ³ãƒ‰ç”Ÿæˆï¼šA,B ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã€C = âˆ’(A+B)
  function generateRound(){
    let A, B, C;
    let safety = 0;
    do{
      safety++;
      A = pickEndpointExceptCenter();
      do{
        B = pickEndpointExceptCenter();
      } while(endpointsEqual(A,B) || endpointOpposite(A,B));
      const dxA = A.i - centerIndex, dyA = A.j - centerIndex;
      const dxB = B.i - centerIndex, dyB = B.j - centerIndex;
      const dxC = -(dxA + dxB), dyC = -(dyA + dyB);
      C = { i: centerIndex + dxC, j: centerIndex + dyC };
      const inBounds = (C.i>=0 && C.i<points && C.j>=0 && C.j<points);
      const notCenter = !(C.i===centerIndex && C.j===centerIndex);
      const distinct = !endpointsEqual(C,A) && !endpointsEqual(C,B);
      if(inBounds && notCenter && distinct) break;
    } while(safety<999);

    forces = {A,B,C};
    lastAnswer = null;
    revealCorrect = false;
    awaitingAnswer = true;
  }

  // ====== æç”» ======
  function drawGrid(){
    const s = spacing();
    ctx.save();
    ctx.lineWidth = Math.max(1, canvas.width/900);
    ctx.strokeStyle = '#1f2635';
    ctx.strokeRect(margin, margin, s*gridSquares, s*gridSquares);

    ctx.strokeStyle = '#20293a';
    for(let i=0;i<=gridSquares;i++){
      const x = margin + i*s, y = margin + i*s;
      ctx.beginPath(); ctx.moveTo(x, margin); ctx.lineTo(x, margin+s*gridSquares); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(margin, y); ctx.lineTo(margin+s*gridSquares, y); ctx.stroke();
    }

    ctx.fillStyle = '#2a3347';
    for(let i=0;i<points;i++){
      for(let j=0;j<points;j++){
        const {x,y} = ijToXY(i,j);
        ctx.beginPath();
        ctx.arc(x,y, Math.max(2, s*0.04), 0, Math.PI*2);
        ctx.fill();
      }
    }
    ctx.restore();
  }

  // ä¸­å¤®ã®çƒï¼ˆå¼·èª¿ï¼‰
  function drawCenterBody(){
    const {x,y} = ijToXY(centerIndex, centerIndex);
    const r = Math.max(10, spacing()*0.18);
    ctx.save();
    ctx.globalAlpha = 0.95;
    const grad = ctx.createRadialGradient(x,y,r*0.15, x,y,r);
    grad.addColorStop(0, '#3a4a6b');
    grad.addColorStop(0.55, '#23304a');
    grad.addColorStop(1, '#101722');
    ctx.fillStyle = grad;

    ctx.shadowColor = 'rgba(120,170,255,0.45)';
    ctx.shadowBlur = Math.max(8, r*0.8);
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();

    ctx.shadowBlur = 0;
    ctx.lineWidth = Math.max(2, r*0.14);
    ctx.strokeStyle = 'rgba(130,180,255,0.55)';
    ctx.stroke();
    ctx.lineWidth = Math.max(1, r*0.06);
    ctx.strokeStyle = '#2e3a52';
    ctx.stroke();
    ctx.restore();
  }

  function drawArrow(from, to, color='#69b7ff', lineDash=null){
    const head = Math.max(8, spacing()*0.22);
    const shaft = Math.max(2, spacing()*0.06);
    ctx.save();
    if(lineDash) ctx.setLineDash(lineDash);
    ctx.lineWidth = shaft;
    ctx.strokeStyle = color;
    ctx.fillStyle = color;

    ctx.beginPath(); ctx.moveTo(from.x, from.y); ctx.lineTo(to.x, to.y); ctx.stroke();

    const dx = to.x - from.x, dy = to.y - from.y;
    const len = Math.hypot(dx,dy);
    if(len > 0.0001){
      const ux = dx/len, uy = dy/len;
      const hx = to.x - ux * head;
      const hy = to.y - uy * head;
      const wing = head * 0.55;
      ctx.beginPath();
      ctx.moveTo(to.x, to.y);
      ctx.lineTo(hx - uy*wing, hy + ux*wing);
      ctx.lineTo(hx + uy*wing, hy - ux*wing);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();
  }

  function drawAssistLine(aIJ, bIJ, temp=false){
    const A = ijToXY(aIJ.i, aIJ.j);
    const B = temp ? bIJ : ijToXY(bIJ.i, bIJ.j);
    ctx.save();
    ctx.setLineDash([6,6]);
    ctx.lineWidth = Math.max(1.5, spacing()*0.05);
    ctx.strokeStyle = '#a4b0c6';
    ctx.beginPath(); ctx.moveTo(A.x, A.y); ctx.lineTo(B.x, B.y); ctx.stroke();
    ctx.restore();
  }

  function drawHoverSnapCircle(i,j){
    const {x,y} = ijToXY(i,j);
    ctx.save();
    ctx.strokeStyle = '#3a4761';
    ctx.lineWidth = Math.max(1, spacing()*0.04);
    ctx.beginPath();
    ctx.arc(x, y, Math.max(10, spacing()*0.22), 0, Math.PI*2);
    ctx.stroke();
    ctx.restore();
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawGrid();

    // è£œåŠ©ç·šï¼ˆç¢ºå®šæ¸ˆã¿ï¼‰
    for(const seg of assistLines){
      drawAssistLine(seg.a, seg.b, false);
    }

    drawCenterBody();

    const O = ijToXY(centerIndex, centerIndex);

    if(forces){
      // è¡¨ç¤ºä¸­ã®2ãƒ™ã‚¯ãƒˆãƒ«
      const Axy = ijToXY(forces.A.i, forces.A.j);
      const Bxy = ijToXY(forces.B.i, forces.B.j);
      drawArrow(O, Axy, '#69b7ff');
      drawArrow(O, Bxy, '#7dffa7');

      // è§£ç­”ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®ä»®è¡¨ç¤º
      if(dragging && dragPos){
        drawArrow(O, dragPos, '#c59eff', [8,6]);
        const snapped = xyToIJ(dragPos.x, dragPos.y);
        if(!(snapped.i===centerIndex && snapped.j===centerIndex)){
          drawHoverSnapCircle(snapped.i, snapped.j);
        }
      }

      // è£œåŠ©ç·šãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®ä»®è¡¨ç¤º
      if(assistDragging && assistStart && assistTempEnd){
        drawAssistLine(assistStart, assistTempEnd, true);
        const snap = xyToIJ(assistTempEnd.x, assistTempEnd.y);
        drawHoverSnapCircle(snap.i, snap.j);
      }

      // æå‡ºæ¸ˆã¿ã®è§£ç­”
      if(lastAnswer){
        const Ans = ijToXY(lastAnswer.i, lastAnswer.j);
        drawArrow(O, Ans, '#c59eff', [8,6]);
      }

      // æ­£è§£ã®å¯è¦–åŒ–
      if(revealCorrect){
        const Cxy = ijToXY(forces.C.i, forces.C.j);
        drawArrow(O, Cxy, '#ffd166');
      }
    }
  }

  // ====== ã‚¿ã‚¤ãƒãƒ¼ ======
  function startTimer(){
    stopTimer();
    timerId = setInterval(() => {
      if(!playing) return;
      const remain = remainingSeconds();
      timeLabel.textContent = Math.max(0, remain).toFixed(2) + 's';
      if(remain <= 0){
        finishGame();
      }
    }, 30);
  }
  function stopTimer(){ if(timerId){ clearInterval(timerId); timerId = null; } }
  function remainingSeconds(){
    if(!startTime) return gameSeconds;
    const elapsed = (performance.now() - startTime) / 1000;
    return gameSeconds - elapsed;
  }

  // ====== é€²è¡Œç®¡ç† ======
  function startGame(){
    score = 0;
    updateScore(0);
    startTime = performance.now();
    playing = true;
    startBtn.disabled = true;
    resetBtn.disabled = false;
    assistLines.length = 0; // ã‚¹ã‚¿ãƒ¼ãƒˆã§è£œåŠ©ç·šã¯ã‚¯ãƒªã‚¢ï¼ˆå¿…è¦ãªã‚‰æ®‹ã™ä»•æ§˜ã«å¤‰æ›´å¯ï¼‰
    nextRound();
    startTimer();
    announce('ã‚¹ã‚¿ãƒ¼ãƒˆï¼ 60ç§’ã§ã§ãã‚‹ã ã‘æ­£è§£ã—ã‚ˆã†ã€‚è£œåŠ©ç·šãƒ¢ãƒ¼ãƒ‰ã¯å¿…è¦ã«å¿œã˜ã¦ON/OFFã—ã¦ã­ã€‚');
  }
  function finishGame(){
    playing = false;
    awaitingAnswer = false;
    revealCorrect = false; // çµ‚äº†æ™‚ã¯æ­£è§£è¡¨ç¤ºã‚ªãƒ•
    stopTimer();
    draw();
    announce(`çµ‚äº†ï¼ ã‚¹ã‚³ã‚¢ï¼š${score} å• æ­£è§£ ğŸ‰ï¼ˆã‚‚ã†ä¸€åº¦æŒ‘æˆ¦ã™ã‚‹ï¼Ÿï¼‰`);
    startBtn.disabled = false;
    startBtn.textContent = 'ã‚‚ã†ä¸€åº¦';
  }
  function nextRound(){
    generateRound();
    draw();
  }
  function updateScore(delta){
    score += delta;
    scoreLabel.textContent = String(score);
  }

  function hardReset(){
    playing = false;
    awaitingAnswer = false;
    revealCorrect = false;
    stopTimer();
    score = 0;
    startTime = null;
    lastAnswer = null;
    forces = null;
    dragging = false; dragPos = null;
    assistDragging = false; assistStart = null; assistTempEnd = null;
    assistLines.length = 0;
    timeLabel.textContent = gameSeconds.toFixed(2)+'s';
    scoreLabel.textContent = '0';
    startBtn.disabled = false;
    startBtn.textContent = 'ã‚¹ã‚¿ãƒ¼ãƒˆ';
    announce('[æ“ä½œ] ã‚¹ã‚¿ãƒ¼ãƒˆå¾Œã€ä¸­å¤®ã‹ã‚‰ãƒ‰ãƒ©ãƒƒã‚°ã§è§£ç­”ã€‚è£œåŠ©ç·šãƒ¢ãƒ¼ãƒ‰ä¸­ã¯è‡ªç”±ã«ç ´ç·šã‚’å¼•ã‘ã¾ã™ï¼ˆã‚‚ã†ä¸€åº¦æŠ¼ã™ã¨è§£é™¤ï¼‰ã€‚');
    fitCanvasDPI();
    draw();
  }

  function announce(text){ msgEl.innerHTML = text.replace(/\n/g,'<br/>'); }

  // ====== è£œåŠ©ç·šãƒ¢ãƒ¼ãƒ‰ ======
  function toggleAssist(){
    assistMode = !assistMode;
    assistBtn.setAttribute('aria-pressed', String(assistMode));
    assistBtn.textContent = assistMode ? 'è£œåŠ©ç·šãƒ¢ãƒ¼ãƒ‰ä¸­ï¼ˆã‚‚ã†ä¸€åº¦ã§è§£é™¤ï¼‰' : 'è£œåŠ©ç·šã‚’å¼•ã';
    announce(assistMode ? 'è£œåŠ©ç·šãƒ¢ãƒ¼ãƒ‰ONï¼šæ ¼å­ç‚¹ã‹ã‚‰æ ¼å­ç‚¹ã¸ãƒ‰ãƒ©ãƒƒã‚°ã§ç ´ç·šã‚’å¼•ã‘ã¾ã™ã€‚' : 'è£œåŠ©ç·šãƒ¢ãƒ¼ãƒ‰OFFã€‚');
  }

  // ====== å…¥åŠ›ï¼šPointer Events ======
  function getCanvasXYFromEvent(e){
    const rect = canvas.getBoundingClientRect();
    const px = (e.clientX - rect.left) * (canvas.width / rect.width);
    const py = (e.clientY - rect.top)  * (canvas.height / rect.height);
    return {x:px, y:py};
  }

  function pointerDown(e){
    const pos = getCanvasXYFromEvent(e);

    // è£œåŠ©ç·šãƒ¢ãƒ¼ãƒ‰
    if(assistMode){
      const startIJ = xyToIJ(pos.x, pos.y);
      assistDragging = true;
      assistStart = startIJ;
      assistTempEnd = pos; // XYã§ä¿æŒã—ã¦ä»®ç·šã‚’å¼•ã
      canvas.setPointerCapture?.(e.pointerId);
      e.preventDefault();
      draw();
      return;
    }

    // é€šå¸¸ï¼šè§£ç­”ãƒ‰ãƒ©ãƒƒã‚°ï¼ˆä¸­å¤®è¿‘å‚ã‹ã‚‰ã®ã¿ï¼‰
    if(!playing || !forces) return;
    const O = ijToXY(centerIndex, centerIndex);
    const r = Math.max(10, spacing()*startFromCenterRadiusFactor);
    if(Math.hypot(pos.x - O.x, pos.y - O.y) <= r * 2.0){
      dragging = true;
      dragPos = pos;
      canvas.setPointerCapture?.(e.pointerId);
      e.preventDefault();
      draw();
    }
  }

  function pointerMove(e){
    const pos = getCanvasXYFromEvent(e);

    if(assistMode){
      if(!assistDragging) return;
      assistTempEnd = pos;
      draw();
      return;
    }

    if(!dragging) return;
    dragPos = pos;
    draw();
  }

  function pointerUp(e){
    const pos = getCanvasXYFromEvent(e);

    if(assistMode){
      if(!assistDragging) return;
      assistDragging = false;
      const endIJ = xyToIJ(pos.x, pos.y);
      // åŒã˜ç‚¹ãªã‚‰ç„¡è¦–
      if(!(assistStart.i===endIJ.i && assistStart.j===endIJ.j)){
        assistLines.push({a: {...assistStart}, b: {...endIJ}});
      }
      assistStart = null;
      assistTempEnd = null;
      draw();
      return;
    }

    if(!dragging) return;
    dragging = false;

    if(!playing || !awaitingAnswer || !forces) { dragPos = null; draw(); return; }

    // è§£ç­”ã‚¹ãƒŠãƒƒãƒ—
    const {i,j} = xyToIJ(pos.x, pos.y);
    if(i===centerIndex && j===centerIndex){
      announce('ä¸­å¤®ï¼ˆç‰©ä½“ä½ç½®ï¼‰ã¯çµ‚ç‚¹ã«ã§ãã¾ã›ã‚“ã€‚ã‚‚ã†ä¸€åº¦ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ã­ã€‚');
      dragPos = null;
      draw();
      return;
    }
    lastAnswer = {i,j};
    dragPos = null;
    draw();

    // åˆ¤å®š â†’ æ­£è§£ãªã‚‰ã‚¹ã‚³ã‚¢+1ã€‚ã©ã¡ã‚‰ã§ã‚‚æ¬¡å•é¡Œã¸
    const correct = (i===forces.C.i && j===forces.C.j);
    if(correct){
      updateScore(1);
      revealCorrect = true; draw();
      setTimeout(() => { revealCorrect = false; awaitingAnswer = true; generateRound(); draw(); }, revealDelayMs);
    }else{
      revealCorrect = true; draw(); // ç­”ãˆã‚’çŸ­ãè¦‹ã›ã‚‹
      setTimeout(() => { revealCorrect = false; awaitingAnswer = true; generateRound(); draw(); }, revealDelayMs);
    }
  }

  canvas.addEventListener('pointerdown', pointerDown, {passive:false});
  canvas.addEventListener('pointermove',  pointerMove,  {passive:false});
  canvas.addEventListener('pointerup',    pointerUp,    {passive:false});
  canvas.addEventListener('pointercancel', () => {
    dragging = false; dragPos = null;
    assistDragging = false; assistTempEnd = null;
    draw();
  });

  // ã‚¿ãƒƒãƒã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æŠ‘æ­¢ï¼ˆã‚­ãƒ£ãƒ³ãƒã‚¹ä¸Šã®ã¿ï¼‰
  canvas.addEventListener('touchstart', (e)=>e.preventDefault(), {passive:false});
  canvas.addEventListener('touchmove',  (e)=>e.preventDefault(), {passive:false});
})();
</script>
</body>
</html>
