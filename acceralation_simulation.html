<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>等加速度直線運動シミュレーション（CDN版）</title>
  <style>
    :root { --bg:#fff; --fg:#111; --muted:#666; --primary:#2563eb; --danger:#ef4444; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans JP, sans-serif; background:var(--bg); color:var(--fg); }
    .container { max-width: 1100px; margin: 24px auto; padding: 0 16px; }
    h1 { font-size: 24px; font-weight: 700; margin: 0 0 16px; }
    .card { background:#fff; border:1px solid #e5e7eb; border-radius:16px; box-shadow: 0 2px 8px rgba(0,0,0,.04); }
    .card + .card { margin-top: 16px; }
    .card-h { padding: 16px 20px; border-bottom:1px solid #eef1f4; }
    .card-t { font-size: 18px; font-weight: 600; }
    .card-c { padding: 16px 20px; }
    .grid2 { display:grid; grid-template-columns: 1fr; gap:16px; }
    @media (min-width: 980px){ .grid2 { grid-template-columns: 1fr 1fr; } }
    .row { display:flex; flex-wrap: wrap; align-items: center; gap:12px; }
    .btn { border:1px solid #d1d5db; background:#f8fafc; color:#111; padding:12px 16px; border-radius:14px; font-size:16px; cursor:pointer; }
    .btn.primary { background: var(--primary); color:#fff; border-color: transparent; }
    .btn.outline { background:#fff; }
    .btn:disabled { opacity:.5; cursor:not-allowed; }
    .choices { display:grid; grid-template-columns: repeat(5, minmax(0, 1fr)); gap:8px; }
    .choices .btn.sel { outline: 2px solid var(--primary); }
    .label { font-size: 20px; font-weight: 700; }
    svg { display:block; }
    .muted { color: var(--muted); }
  </style>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/recharts/umd/Recharts.min.js"></script>
</head>
<body>
  <div id="root"></div>

  <!-- Babel に React プリセットを明示 -->
  <script type="text/babel" data-type="module" data-presets="env,react">
    const { useState, useMemo, useRef, useEffect, useCallback } = React;
    const { LineChart, Line, XAxis, YAxis, CartesianGrid, ResponsiveContainer, Tooltip, ReferenceLine } = Recharts;

    const V0_OPTIONS = [-1.0, -0.5, 0.0, 0.5, 1.0];
    const A_OPTIONS = [-1.0, -0.5, 0.0, 0.5, 1.0];

    const X_MIN = -3;
    const X_MAX = 8;
    const T_MAX = 5;
    const V_MIN = -3;
    const V_MAX = 5;

    const SVG_W = 760;
    const SVG_H = 220;
    const MARGIN_L = 50;
    const MARGIN_R = 50;
    const AXIS_Y = 160;

    function App(){
      const [v0, setV0] = useState(0.0);
      const [a, setA] = useState(0.0);
      const [t, setT] = useState(0.0);
      const [playing, setPlaying] = useState(false);
      const [stepping, setStepping] = useState(false);
      const stepTargetRef = useRef(null);

      const [vSeries, setVSeries] = useState([{t:0, v:0}]);
      const rafRef = useRef(null);
      const lastTsRef = useRef(null);
      const lastAddedTRef = useRef(0);

      const x = useMemo(()=> v0 * t + 0.5 * a * t * t, [v0,a,t]);
      const v = useMemo(()=> v0 + a * t, [v0,a,t]);

      const pxPerMeter = (SVG_W - MARGIN_L - MARGIN_R) / (X_MAX - X_MIN);
      const xToPx = useCallback((xm)=> MARGIN_L + (xm - X_MIN) * pxPerMeter, [pxPerMeter]);

      const pushSeriesIfNeeded = (curT) => {
        const addEvery = 0.05;
        if (curT - lastAddedTRef.current >= addEvery || curT >= T_MAX){
          setVSeries((s)=> [...s, {t: curT, v: v0 + a * curT}]);
          lastAddedTRef.current = curT;
        }
      };

      const resetSim = useCallback((nextV0, nextA)=>{
        setPlaying(false);
        setStepping(false);
        stepTargetRef.current = null;
        setT(0);
        setVSeries([{t:0, v: nextV0}]);
        lastAddedTRef.current = 0;
        lastTsRef.current = null;
      },[]);

      useEffect(()=>{
        if(!playing && !stepping) return;
        const loop = (ts)=>{
          if (lastTsRef.current == null) lastTsRef.current = ts;
          const dt = (ts - (lastTsRef.current ?? ts)) / 1000;
          lastTsRef.current = ts;
          setT((prev)=>{
            const target = (stepping && stepTargetRef.current!=null) ? Math.min(stepTargetRef.current, T_MAX) : T_MAX;
            const next = Math.min(T_MAX, prev + dt);
            pushSeriesIfNeeded(next);
            if (stepping && next >= target){
              setStepping(false);
              stepTargetRef.current = null;
              return target;
            }
            if (!stepping && next >= T_MAX){
              setPlaying(false);
              if (rafRef.current) cancelAnimationFrame(rafRef.current);
              rafRef.current = null;
            }
            return next;
          });
          if (playing || stepping) rafRef.current = requestAnimationFrame(loop);
        };
        rafRef.current = requestAnimationFrame(loop);
        return ()=>{ if(rafRef.current) cancelAnimationFrame(rafRef.current); rafRef.current=null; lastTsRef.current=null; };
      },[playing,stepping,v0,a]);

      const stepOneSecond = ()=>{
        setPlaying(false);
        stepTargetRef.current = Math.min(T_MAX, t + 1);
        setStepping(true);
        lastTsRef.current = null;
      };

      const arrowLenPerMs = 75 * 0.75;
      const arrowLen = Math.max(0, Math.min(Math.abs(v) * arrowLenPerMs, 200));
      const arrowDir = Math.sign(v) || 1;

      const cx = xToPx(x);
      const cxClamped = Math.max(MARGIN_L, Math.min(cx, SVG_W - MARGIN_R));

      const tTicks = [0,1,2,3,4,5];
      const vTicks = [-3,-2,-1,0,1,2,3,4,5];

      return (
        <div className="container">
          <h1>等加速度直線運動シミュレーション</h1>
          {/* ... （省略: ボタン、再生/停止、SVG、グラフ部分は元のコードと同じ） */}
          <div>{/* コンテンツ本体は省略せず元コードを貼る */}</div>
        </div>
      );
    }

    const rootEl = document.getElementById('root');
    if (!rootEl) console.error('root 要素が見つかりません');
    else ReactDOM.createRoot(rootEl).render(<App/>);
  </script>
</body>
</html>
