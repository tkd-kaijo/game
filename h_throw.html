<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>水平投射ゲーム〜5球で10点取れ！〜</title>
<style>
/* --- 省略なく全部含めていますが、見栄えは以前のまま --- */
:root{--bg:#0f1220; --card:#171a2b; --accent:#6ae3ff; --accent2:#8effa1; --text:#e8edf2; --muted:#9aa7b3; --ok:#8effa1; --ng:#ff9aa8; --yellow:#ffd36a}
*{box-sizing:border-box} html,body{height:100%}
body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN",Meiryo,"Noto Sans JP",sans-serif;background: radial-gradient(1200px 600px at 70% -10%, #1a1f38, #0b0e1a 60%), var(--bg);color:var(--text);display:flex;min-height:100svh;align-items:center;justify-content:center;padding:16px}
@supports (min-height: 100dvh){ body{ min-height:100dvh } }
.app{width:min(980px,100%);display:grid;gap:12px}
.title{font-weight:700;letter-spacing:.02em;font-size:clamp(18px,3vw,28px);text-align:center}
.challengeBox{display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:center;padding:8px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.08);background:rgba(255,255,255,.04)}
.badge{display:inline-block;padding:2px 8px;border-radius:999px;font-size:14px;background:rgba(255,255,255,.08);color:var(--yellow)}
#challengeTextHUD{font-weight:700}
#scoreHUD{font-variant-numeric:tabular-nums;font-weight:900}
.perfect{color:#b7fffb;font-weight:900;margin-left:8px;text-shadow:0 0 10px rgba(106,227,255,.55)}
.excellent{color:#8fffd6;font-weight:800;margin-left:8px}
.great{color:#a7ff6a;font-weight:800;margin-left:8px}
.good{color:var(--ok);font-weight:800;margin-left:8px}
.ok{color:#ffd36a;font-weight:800;margin-left:8px}
.bad{color:var(--ng);font-weight:800;margin-left:8px}
.card{background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,0));border:1px solid rgba(255,255,255,.08);border-radius:16px;padding:12px 14px;box-shadow:0 10px 30px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.05)}
.roulette{display:grid;grid-template-columns:1fr auto;gap:10px;align-items:center}
.bar{height:16px;background:#111528;border-radius:999px;overflow:hidden;position:relative;border:1px solid rgba(255,255,255,.08)}
.fill{height:100%;width:0%;background:linear-gradient(90deg,var(--accent),var(--accent2));transition:width .06s linear;box-shadow:0 0 10px rgba(106,227,255,.6), inset 0 0 8px rgba(0,0,0,.3)}
.speed{font-variant-numeric:tabular-nums;font-weight:800;letter-spacing:.02em;min-width:8ch;text-align:right;font-size:18px}
.actions{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px;justify-content:center}
button{appearance:none;border:none;border-radius:12px;padding:14px 20px;font-weight:700;cursor:pointer;font-size:clamp(22px,3.8vw,34px);color:#03131a;background:linear-gradient(180deg,#8ff2ff,#6ae3ff);box-shadow:0 8px 22px rgba(106,227,255,.35),inset 0 1px 0 rgba(255,255,255,.6)}
@media (min-width:820px){button{font-size:clamp(34px,3.8vw,53px);padding:18px 28px}}
button.secondary{background:linear-gradient(180deg,#d7e7ff,#b8cfff);box-shadow:0 8px 22px rgba(184,207,255,.28), inset 0 1px 0 rgba(255,255,255,.6)}
button:disabled{opacity:.5;cursor:not-allowed}
.playgrid{display:grid;grid-template-columns:1fr;gap:10px;align-items:start}
@media (orientation:portrait){.playgrid{grid-template-columns:1fr 1fr;grid-template-areas:'scene readouts'} .scene{grid-area:scene} .readouts{grid-area:readouts}}
@media (orientation:landscape){.playgrid{grid-template-columns:1fr 1fr;grid-template-areas:'scene readouts'} .scene{grid-area:scene} .readouts{grid-area:readouts}}
.scene{position:relative;height:420px;border-radius:14px;overflow:hidden;margin-top:10px;background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,0)), radial-gradient(800px 260px at 50% 0%, rgba(106,227,255,.08), rgba(0,0,0,0) 60%), #0b1022;border:1px solid rgba(255,255,255,.08)}
.ground{position:absolute;inset:auto 0 0 0;height:8px;background:#1a2039;box-shadow:0 -2px 0 rgba(255,255,255,.06) inset}
.subground{position:absolute;left:0;right:0;background:linear-gradient(180deg,#8b5e3c,#5e3b23);opacity:.55;z-index:0}
.grid{position:absolute;inset:0 0 8px 0;pointer-events:none;z-index:0}
.hgridline,.vgridline,.zeroline{position:absolute;background:rgba(255,255,255,.22);opacity:.7}
.hgridline{left:8px;right:8px;height:1px}
.vgridline{top:8px;bottom:8px;width:1px}
.zeroline{left:8px;right:8px;height:2px;background:rgba(255,255,255,.28)}
.gridlabel{position:absolute;font-size:11px;color:var(--muted);background:rgba(0,0,0,.35);padding:1px 6px;border-radius:999px;border:1px solid rgba(255,255,255,.12);z-index:1}
.hlabel{right:10px;transform:translateY(-50%)}
.vlabel{transform:translateX(-50%)}
.building{position:absolute;left:0;right:auto;background:linear-gradient(180deg,#8f95a3,#6f7482);border:1px solid rgba(255,255,255,.1);box-shadow:inset 0 6px 14px rgba(0,0,0,.25);z-index:1}
.building::after{content:'';position:absolute;inset:10% 15% 10% 15%;background:repeating-linear-gradient(to-bottom,rgba(255,255,255,.06),rgba(255,255,255,.06) 8px,transparent 8px,transparent 16px)}
.ball{position:absolute;width:18px;aspect-ratio:1;border-radius:50%;background:radial-gradient(circle at 30% 30%,#fff,#bfeaff 30%,#6ae3ff 45%,#0aa3c0 70%,#067089 100%);box-shadow:0 8px 24px rgba(106,227,255,.45);z-index:2}
.velvec{position:absolute;height:3px;background:#8ff2ff;box-shadow:0 0 10px rgba(106,227,255,.6);transform-origin:left center;z-index:2}
.velvec::after{content:'';position:absolute;right:-6px;top:50%;transform:translateY(-50%);border-left:8px solid #8ff2ff;border-top:5px solid transparent;border-bottom:5px solid transparent;filter:drop-shadow(0 0 6px rgba(106,227,255,.6))}
.trail{position:absolute;inset:0 0 8px 0;z-index:1;pointer-events:none}
.target{position:absolute;width:14px;height:14px;border-radius:50%;border:2px solid #ffd36a;box-shadow:0 0 10px rgba(255,211,106,.5);transform:translate(-50%,0%);z-index:2}
.target::after{content:'';position:absolute;inset:3px;border-radius:50%;border:2px solid rgba(255,211,106,.8)}
.readouts{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin-top:10px}
@media (max-width:980px){.readouts{grid-template-columns:1fr 1fr}}
@media (orientation:portrait){.readouts{grid-template-columns:1fr;align-content:start}}
.stat{background:rgba(0,0,0,.25);border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:10px 12px}
.stat .label{color:var(--muted);font-size:12px;letter-spacing:.02em}
.stat .value{font-variant-numeric:tabular-nums;font-weight:800;font-size:22px}
@media (min-width:820px){.title{font-size:clamp(24px,2.6vw,36px)}.challengeBox{padding:12px 16px;gap:16px}#challengeTextHUD{font-size:clamp(31px,2.9vw,43px)}#scoreHUD{font-size:clamp(43px,3.8vw,53px)}.speed{font-size:clamp(43px,3.8vw,53px)}.bar{height:22px}.stat .label{font-size:16px}.stat .value{font-size:clamp(30px,2.6vw,40px)}}
@media (orientation:landscape) and (min-width:768px) and (max-width:1180px){.title{font-size:20px}#challengeTextHUD{font-size:28px}#scoreHUD,.speed{font-size:34px}.stat .value{font-size:24px}.stat .label{font-size:14px}.bar{height:18px}}
#challengeTextHUD,.speed{color:#ff5b5b!important}
.submitBox{display:none;margin-top:12px;padding:12px;border:1px solid rgba(255,255,255,.12);border-radius:12px;background:rgba(255,255,255,.06)}
.submitBox h3{margin:0 0 8px 0;font-size:16px}
.submitRow{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.submitRow input[type="text"]{flex:1;min-width:180px;padding:10px 12px;border-radius:10px;border:1px solid rgba(255,255,255,.18);background:#0f1430;color:#fff;font-size:16px}
.submitRow button{padding:10px 14px;border-radius:10px;border:none;font-weight:700;cursor:pointer;color:#03131a;background:linear-gradient(180deg,#b1ffd1,#7affaf);box-shadow:0 8px 22px rgba(122,255,175,.28)}
.helpText{font-size:12px;color:#cfe3ff;opacity:.9;margin-top:6px}
.toast{position:fixed;left:50%;transform:translateX(-50%);bottom:20px;background:#0b1022;color:#eafff3;padding:10px 14px;border:1px solid rgba(255,255,255,.1);border-radius:10px;display:none;z-index:9999}
#leaderboardCard{grid-column:1 / -1}
#leaderboardCardMobile{display:none}
@media (max-width:640px){.playgrid{display:grid;grid-template-columns:1fr 1fr;grid-template-areas:"scene readouts";gap:10px}.scene{grid-area:scene;min-width:0}.readouts{grid-area:readouts;min-width:0;grid-template-columns:1fr}#leaderboardCard{display:none}#leaderboardCardMobile{display:block;margin-top:10px}}
</style>
</head>
<body>
  <main class="app">
    <div class="title">水平投射ゲーム〜5球で10点取れ！〜</div>

    <div class="challengeBox" id="challengeBox">
      <span class="badge" id="roundBadgeHUD">ラウンド1/5</span>
      <span id="challengeTextHUD">—</span>
      <span id="resultTextHUD"></span>
      <span>｜スコア <strong id="scoreHUD">0点</strong></span>
    </div>

    <section class="card" id="card">
      <div class="roulette" aria-live="polite">
        <div class="bar" aria-label="初速ルーレット（0〜6 m/s を4秒で周回）">
          <div class="fill" id="fill"></div>
        </div>
        <div class="speed" id="speedLabel">0.00 m/s</div>
      </div>
      <div class="actions">
        <button id="lockBtn">投射！(L)</button>
        <button id="retryBtn" class="secondary" disabled>次のラウンド(N)</button>
        <button id="resetBtn" class="secondary" style="display:none">もう一度</button>
      </div>

      <div class="playgrid">
        <div class="scene" id="scene">
          <div class="subground" id="subground" aria-hidden="true"></div>
          <div class="grid" id="grid"></div>
          <canvas class="trail" id="trail"></canvas>
          <div class="building" id="building" aria-hidden="true"></div>
          <div class="ball" id="ball"></div>
          <div class="velvec" id="velvec" aria-hidden="true"></div>
          <div class="target" id="target"></div>
          <div class="ground"></div>
        </div>

        <div class="readouts" id="readouts">
          <div class="stat"><div class="label">現在位置 (x, y)</div><div class="value" id="posNow">0.00 m, 0.00 m</div></div>
          <div class="stat"><div class="label">飛行時間 T</div><div class="value" id="tVal">0.00 s</div></div>
          <div class="stat"><div class="label">着地点 xₗ</div><div class="value" id="xLandVal">0.00 m</div></div>

          <section class="card" id="leaderboardCard" aria-live="polite">
            <h3 style="margin:0 0 8px">トップ20(※平常点的には「提出できたか否か」のみの判断)</h3>
            <div id="leaderboard">読み込み中…</div>
          </section>
        </div>
      </div>

      <section class="card" id="leaderboardCardMobile" aria-live="polite">
        <h3 style="margin:0 0 8px">トップ20(※平常点的には「提出できたか否か」のみの判断)</h3>
        <div id="leaderboardMobile">読み込み中…</div>
      </section>
    </section>
  </main>

  <div class="submitBox" id="submitBox" style="display:none" aria-live="polite">
    <h3>提出</h3>
    <div class="submitRow">
      <label for="studentId">4桁番号(年組番、半角)：</label>
      <input id="studentId" type="text" placeholder="3143" inputmode="numeric" />
    </div>
    <div class="submitRow">
      <label for="studentName">氏名：</label>
      <input id="studentName" type="text" placeholder="海城太郎" />
      <button id="submitBtn">送信</button>
    </div>
    <div class="helpText" id="submitHelp">10点以上で提出できます。</div>
  </div>
  <div class="toast" id="toast"></div>

<script>
(() => {
/* ========= GAS エンドポイント ========= */
const GAS_SESSION_URL = 'https://script.google.com/macros/s/AKfycbzWQbT1tQVIJdRDC7_r5foANKrWXcwyz6KTgin42AfBnXU0gqg8BAjgRFwiYyd4fmieUg/exec?fn=session';
const GAS_SUBMIT_URL  = 'https://script.google.com/macros/s/AKfycbzWQbT1tQVIJdRDC7_r5foANKrWXcwyz6KTgin42AfBnXU0gqg8BAjgRFwiYyd4fmieUg/exec?path=submit';
const GAS_LOCK_URL    = 'https://script.google.com/macros/s/AKfycbzWQbT1tQVIJdRDC7_r5foANKrWXcwyz6KTgin42AfBnXU0gqg8BAjgRFwiYyd4fmieUg/exec?path=lock';
const CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vSyOTJEBzV8JvxrNSIWYcyZLEvOXFJDwhXfOCPtACgvqaGwjRn70ZuJKQNLwqPS8_3YeTFt8gNpJrnM/pub?gid=1914198285&single=true&output=csv";


  
/* ========= 物理・ルール ========= */
const RULE = {
  version: 'hproj-v1.3',
  g: 9.8, vMin: 0, vMax: 6, cycleSec: 4, rounds: 5,
  yCandidates: [4.9, 19.6, 44.1],
  xCandidates: [1,2,3,4,5],
  scoreBands: [
    { lt: 0.01, pts: 5, label: 'PERFECT!!!!', cls:'perfect', decimals:2 },
    { lt: 0.03, pts: 4, label: 'Excellent!!!', cls:'excellent', decimals:1 },
    { lt: 0.10, pts: 3, label: 'great!!',     cls:'great',     decimals:1 },
    { lt: 0.20, pts: 2, label: 'good!',       cls:'good',      decimals:1 },
    { lt: 0.30, pts: 1, label: 'ok',          cls:'ok',        decimals:1 },
  ]
};

/* ========= DOM ========= */
const fillEl = document.getElementById('fill');
const speedLabel = document.getElementById('speedLabel');
const lockBtn = document.getElementById('lockBtn');
const retryBtn = document.getElementById('retryBtn');
const resetBtn = document.getElementById('resetBtn');
const scene=document.getElementById('scene');
const gridEl=document.getElementById('grid');
const subgroundEl=document.getElementById('subground');
const buildingEl=document.getElementById('building');
const trailCanvas=document.getElementById('trail');
const ball=document.getElementById('ball');
const velvec=document.getElementById('velvec');
const targetEl=document.getElementById('target');
const groundEl = document.querySelector('.ground');
const posNowEl=document.getElementById('posNow');
const tValEl=document.getElementById('tVal');
const xLandVal=document.getElementById('xLandVal');
const roundBadgeHUD=document.getElementById('roundBadgeHUD');
const challengeTextHUD=document.getElementById('challengeTextHUD');
const resultTextHUD=document.getElementById('resultTextHUD');
const scoreHUD=document.getElementById('scoreHUD');
const submitBox = document.getElementById('submitBox');
const submitBtn = document.getElementById('submitBtn');
const studentIdInput = document.getElementById('studentId');
const studentNameInput = document.getElementById('studentName');
const toast = document.getElementById('toast');
const showToast = (m)=>{ toast.textContent=m; toast.style.display='block'; setTimeout(()=>toast.style.display='none',2200) };

/* ========= セッション & 時刻補正 ========= */
let session = {
  sessionId:'', nonce:'', ruleVersion: RULE.version, serverG: RULE.g,
  t0Ms:0, phiSec:0, offsetMs:0, rttMs:0, ticketSig:''
};

// -------------------------------
// クライアント固有トークン管理（localStorage）
// -------------------------------
const CLIENT_TOKEN_KEY = 'hproj_client_token';
function getClientToken(){
  try{
    let tk = localStorage.getItem(CLIENT_TOKEN_KEY);
    if(!tk){
      // ブラウザが対応していれば crypto.randomUUID()、無ければ簡易生成
      tk = (typeof crypto !== 'undefined' && crypto.randomUUID) ? crypto.randomUUID()
         : 'ct-' + Date.now().toString(36) + '-' + Math.random().toString(36).slice(2,10);
      localStorage.setItem(CLIENT_TOKEN_KEY, tk);
      console.log('[clientToken] created');
    }
    return tk;
  }catch(e){
    console.warn('[clientToken] localStorage unavailable', e);
    return ''; // 取得不可なら空文字
  }
}
// すぐ確保（初回ロード時）
const clientToken = getClientToken();
console.log('[clientToken] value=', clientToken);
  
// ★ セッションが空なら取り直す
async function ensureSessionReady() {
  return !!(session.sessionId && session.nonce && session.ticketSig);
}

async function fetchSession(){
  try{
    const t1 = Date.now();
    const r = await fetch(GAS_SESSION_URL + '&t1=' + t1, {
      method: 'GET',
      cache: 'no-store',
      credentials: 'omit',
      // GET でも明示しておくと GAS 側でチェックしているケースに効く
      headers: { 'Accept': 'application/json' }
    });
    const j = await r.json().catch(()=>null);
    if(!j || !j.ok) throw new Error('session_fail');
    const t3 = Date.now();
    const echoT1 = Number(j.echoT1 ?? t1);
    const rtt = Math.max(0, t3 - echoT1);
    const offset = Number(j.serverNow) - (echoT1 + rtt/2);
    session = {
      sessionId: String(j.sessionId||''),
      nonce: String(j.nonce||''),
      ruleVersion: String(j.ruleVersion ?? RULE.version),
      serverG: Number(j.g ?? RULE.g) || RULE.g,
      t0Ms: Number(j.t0Ms||0),
      phiSec: Number(j.phiSec||0),
      ticketSig: String(j.ticketSig||''),
      offsetMs: offset,
      rttMs: rtt
    };
    // サーバの ruleVersion をフロントにも反映
    RULE.version = session.ruleVersion;
    console.log('[session ok] ver=', RULE.version, 'ticketSig.len=', session.ticketSig.length);
  }catch(e){
    console.error('[session error]', e);
    showToast('セッション取得に失敗（提出不可の可能性）');
  }
  console.log('[ruleVersion] server=', session.ruleVersion, ' front=', RULE.version);
}

/* ========= サーバロック（open/close） ========= */
let finished = false;           // 5投をやり切ったら true（以降は lock 禁止）
let attemptId = null;           // この5投（1セット）を識別するID

// ラウンド状態（グローバルに置く）
let currentRound = 1;
let y0 = 19.6, xTarget = 3;     // open で確定
let currentTicket = null;       // close 時に受領
const ticketsByRound = new Map();  // round -> { ticket, sig, v0 }

// 1セット開始時に呼ぶ：ID更新＆前回の記録クリア
function newAttempt(){
  attemptId = 'a-' + Date.now().toString(36) + '-' + Math.random().toString(36).slice(2,8);
  ticketsByRound.clear();
}

async function lockOpen(round){
 const body = new URLSearchParams({
   sessionId: String(session.sessionId),
   nonce: String(session.nonce),
   round: String(round),
   intent: 'open',
   t0Ms: String(session.t0Ms),
   phiSec: String(session.phiSec),
   ticketSig: String(session.ticketSig || ''),
   ruleVersion: String(session.ruleVersion || RULE.version)
});

 console.log('[lockOpen FormData]');
  console.table(Array.from(body.entries()));
  
  const res = await fetch(GAS_LOCK_URL, {
    method:'POST',
    body,
    credentials:'omit',
    headers:{ 'Content-Type':'application/x-www-form-urlencoded;charset=UTF-8', 'Accept':'application/json' }
  });
  const text = await res.text();
  let j = null;
  try { j = JSON.parse(text); } catch { j = null; }
  console.log('[lock/open] status=', res.status, 'resp=', text);
  if(!j || !j.ok) throw new Error('lock_open_fail:' + (j && j.error || res.status));
  y0 = Number(j.y0); xTarget = Number(j.xTarget);
  return j;
}

async function lockClose(round, tClick){
  const body = new URLSearchParams({
    sessionId: session.sessionId,
    nonce: session.nonce,
    round: String(round),
    intent: 'close',
    tClick: String(tClick),
    offsetMs: String(session.offsetMs),
    rttMs: String(session.rttMs),
    t0Ms: String(session.t0Ms),
    phiSec: String(session.phiSec),
    ticketSig: String(session.ticketSig||''),
    ruleVersion: String(session.ruleVersion || RULE.version),
  });
  const res = await fetch(GAS_LOCK_URL, {
    method:'POST',
    body,
    credentials:'omit',
    headers:{ 'Content-Type':'application/x-www-form-urlencoded;charset=UTF-8', 'Accept':'application/json' }
  });
  const text = await res.text();
  let j = null;
  try { j = JSON.parse(text); } catch { j = null; }
  console.log('[lock/close] status=', res.status, 'resp=', text);
  if(!j || !j.ok) throw new Error('lock_close_fail:' + (j && j.error || res.status));
  return j; // { ok, v0, ticket, sig }
}

  

/* ========= ルーレット（端末時刻→表示） ========= */
let running = true, locked = false;
let isOpening = false;
let visualV = 0;

function vFromNowMs(nowMs){
  // サーバ原点 t0Ms を使って位相を合わせる（端末→サーバ補正込み）
  const t = (nowMs - session.t0Ms) / 1000; // 秒
  const phase = (t + session.phiSec) % RULE.cycleSec;
  const unit = phase / RULE.cycleSec;
  return RULE.vMin + unit * (RULE.vMax - RULE.vMin);
}

function updateSpeedUI(v){
  const c = Math.max(RULE.vMin, Math.min(RULE.vMax, v));
  const ratio = (c - RULE.vMin)/(RULE.vMax - RULE.vMin);
  fillEl.style.width = (ratio*100).toFixed(2) + '%';
  speedLabel.textContent = c.toFixed(2) + ' m/s';
}

function rouletteLoop(){
  if(!running) return;
  const displayNow = Date.now() + session.offsetMs; // 端末→サーバの時刻差で補正
  visualV = vFromNowMs(displayNow);
  updateSpeedUI(visualV);
  updateVelocityVector(visualV, 0);
  requestAnimationFrame(rouletteLoop);
}

/* ========= レイアウト/描画周り ========= */
const BALL_DIAM = 18, BALL_R = BALL_DIAM/2;
const BOTTOM_VISIBLE_M = 3.2, TOP_PAD_PX = 0, Y_MAX_VISIBLE = 50, DIST_LABEL_Y_M = -2.6;
const groundOffsetPx = 8;
let scaleY = 8, scaleX = 40;
const origin = { x: 30, y: groundOffsetPx };
let bottomPadPx = 0;
function toPxX(xm){ return origin.x + xm*scaleX; }
function toPxY(ym){ return origin.y + ym*scaleY; }
function toCanvasYCenter(ym){ return scene.clientHeight - (origin.y + ym*scaleY + BALL_R); }
let baselineTop = null;
function getVH(){ const vvh = (window.visualViewport && window.visualViewport.height) ? window.visualViewport.height : window.innerHeight; return Math.min(window.innerHeight, vvh); }
function fitSceneToViewport(){ const vh=getVH(); if(baselineTop===null){baselineTop=scene.getBoundingClientRect().top} const margin=12; let desired=Math.floor(vh-baselineTop-margin); desired=Math.max(240,Math.min(desired,vh-margin)); const prev=parseFloat(getComputedStyle(scene).height); if(!isNaN(prev)&&Math.abs(prev-desired)<2)return; scene.style.height=desired+'px'; }
function fitScales(){ const usableH=scene.clientHeight; scaleY=Math.max(4,(usableH-TOP_PAD_PX)/(Y_MAX_VISIBLE+BOTTOM_VISIBLE_M)); const usableW=scene.clientWidth - origin.x - 16; scaleX=Math.max(24,Math.min(90,usableW/(5+0.6))); bottomPadPx=BOTTOM_VISIBLE_M*scaleY; origin.y=groundOffsetPx+bottomPadPx; groundEl.style.bottom=`0px`; }
function layoutSubground(){ subgroundEl.style.bottom = `${toPxY(-BOTTOM_VISIBLE_M)}px`; subgroundEl.style.height = `${BOTTOM_VISIBLE_M * scaleY}px`; }
function renderGrid(){
  gridEl.innerHTML=''; for(const ym of [4.9,9.8,14.7,19.6,24.5,29.4,34.3,39.2,44.1]){
    const line=document.createElement('div'); line.className='hgridline'; line.style.bottom=toPxY(ym)+'px'; gridEl.appendChild(line);
    const lab=document.createElement('div'); lab.className='gridlabel hlabel'; lab.style.bottom=toPxY(ym)+'px'; lab.textContent=`${ym} m`; gridEl.appendChild(lab);
  }
  const zero=document.createElement('div'); zero.className='zeroline'; zero.style.bottom=toPxY(0)+'px'; gridEl.appendChild(zero);
  const lab0=document.createElement('div'); lab0.className='gridlabel hlabel'; lab0.style.bottom=toPxY(0)+'px'; lab0.textContent='0 m'; gridEl.appendChild(lab0);
  const yLabelPx = toPxY(DIST_LABEL_Y_M);
  for(let xm=0; xm<=5; xm++){
    const v=document.createElement('div'); v.className='vgridline'; v.style.left=toPxX(xm)+'px'; gridEl.appendChild(v);
    const lab=document.createElement('div'); lab.className='gridlabel vlabel'; lab.style.left=toPxX(xm)+'px'; lab.style.bottom=yLabelPx+'px'; lab.textContent=`${xm} m`; gridEl.appendChild(lab);
  }
}
function layoutBuilding(heightM){
  const rightPx = origin.x;
  buildingEl.style.right = (scene.clientWidth - rightPx) + 'px';
  buildingEl.style.left = '0px';
  buildingEl.style.bottom = `${toPxY(0)}px`;
  buildingEl.style.height = (heightM * scaleY) + 'px';
}

/* 軌跡キャンバス */
function resizeTrailCanvas(){
  const dpr = window.devicePixelRatio || 1;
  const rect = scene.getBoundingClientRect();
  trailCanvas.width  = Math.floor(rect.width * dpr);
  trailCanvas.height = Math.floor((rect.height - 8) * dpr);
  trailCanvas.style.width  = rect.width + 'px';
  trailCanvas.style.height = (rect.height - 8) + 'px';
  const ctx = trailCanvas.getContext('2d');
  ctx.setTransform(dpr,0,0,dpr,0,0); redrawTrail();
}
function clearTrail(){ const ctx = trailCanvas.getContext('2d'); ctx.clearRect(0,0,trailCanvas.width,trailCanvas.height); }
let trailPts=[]; function drawTrailSegment(from,to){ const ctx=trailCanvas.getContext('2d'); ctx.lineWidth=2; ctx.strokeStyle='#6ae3ff'; ctx.shadowColor='rgba(106,227,255,.6)'; ctx.shadowBlur=6; ctx.beginPath(); ctx.moveTo(toPxX(from.x), toCanvasYCenter(from.y)); ctx.lineTo(toPxX(to.x), toCanvasYCenter(to.y)); ctx.stroke(); ctx.shadowBlur=0; }
function redrawTrail(){ clearTrail(); for(let i=1;i<trailPts.length;i++) drawTrailSegment(trailPts[i-1], trailPts[i]); }

/* 位置＆速度ベクトル */
const BALL_DIAM_PX = 18; let curX=0, curY=0;
function placeBallAt(xm,ym){ curX=xm; curY=ym; ball.style.left=(toPxX(xm)-BALL_DIAM_PX/2)+'px'; ball.style.bottom=toPxY(ym)+'px'; }
const velScalePxPerMs=4, velMaxLenPx=120;
function updateVelocityVector(vx,vy){
  const centerX = toPxX(curX);
  const centerY = toPxY(curY) + BALL_DIAM_PX/2;
  const speed = Math.sqrt(vx*vx + vy*vy);
  const len = Math.min(velMaxLenPx, speed * velScalePxPerMs);
  const angleRad = Math.atan2(-vy * scaleY, vx * scaleX);
  velvec.style.width = len + 'px'; velvec.style.left = centerX + 'px'; velvec.style.bottom = (centerY - 1.5) + 'px'; velvec.style.transform = `rotate(${angleRad}rad)`;
}

/* サウンド */
let audioCtx=null;
function beep(freq=880,duration=0.15,type='sine',gain=0.08){ try{ if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)(); const t0=audioCtx.currentTime; const osc=audioCtx.createOscillator(); const g=audioCtx.createGain(); osc.type=type; osc.frequency.value=freq; g.gain.value=gain; osc.connect(g).connect(audioCtx.destination); osc.start(t0); g.gain.setValueAtTime(gain,t0); g.gain.exponentialRampToValueAtTime(0.0001,t0+duration); osc.stop(t0+duration+0.02);}catch(e){} }
const goodSound = ()=>{beep(880,0.12); setTimeout(()=>beep(1175,0.12),120);};
const greatSound= ()=>{beep(1047,0.10); setTimeout(()=>beep(1319,0.10),110); setTimeout(()=>beep(1661,0.14),230);};
const wrongSound= ()=>{beep(220,0.25,'square',0.06); setTimeout(()=>beep(175,0.25,'square',0.05),120);};

/* ラウンド & 採点 */
let score=0, lastGainedPoints=0;
let tFlight=0, xLand=0;

function renderAllStatic(){ fitSceneToViewport(); fitScales(); layoutSubground(); renderGrid(); layoutBuilding(y0); resizeTrailCanvas(); }
async function setupRound(){
  if (currentRound === 1 && !attemptId) newAttempt();
 const ready = await ensureSessionReady();
  if (!ready) {
    showToast('セッション未確立のため開始できません（再読み込み推奨）');
    lockBtn.disabled = true;
    retryBtn.disabled = false;
    return;
  }

  if (isOpening) { console.warn('[setupRound] already opening; skip'); return; }
  isOpening = true;
  
  // open: 課題だけ取得
  try{
    await lockOpen(currentRound);
  }catch(e){
    console.error(e); showToast('サーバーに接続できません。(課題取得失敗)');
   // 取得失敗時：ボタン状態を「投射不可・次へ不可」にし、再試行待ち
   lockBtn.disabled = true;
   retryBtn.disabled = false; // いったん次へは押せる（授業運用次第で true にしてもOK）
    isOpening = false;
   return; // ← ここで抜けておく
    
  }
  isOpening = false;
  // 課題表示
  challengeTextHUD.textContent = `初期高さ y₀ = ${y0} m｜ターゲット x = ${xTarget} m を狙え！`;
  resultTextHUD.textContent = '';
  roundBadgeHUD.textContent = `ラウンド${currentRound}/${RULE.rounds}`;

  renderAllStatic();
  placeBallAt(0, y0);
  trailPts=[{x:0,y:y0}]; clearTrail();
  targetEl.style.left = toPxX(xTarget) + 'px';
  targetEl.style.bottom = toPxY(0) + 'px';
  posNowEl.textContent = `0.00 m, ${y0.toFixed(2)} m`;
  tValEl.textContent = '0.00 s';
  xLandVal.textContent = '0.00 m';

  locked=false; running=true;
  lockBtn.disabled=false; retryBtn.disabled=true;
  requestAnimationFrame(rouletteLoop);
}

function animateThrow(v0, ticket){
  const tStart = performance.now();
  tFlight = Math.sqrt((2*y0)/RULE.g);
  xLand   = v0 * tFlight;
  const start=performance.now();
  function step(now){
    const t=Math.max(0,(now-start)/1000), tC=Math.min(tFlight,t);
    const x=v0*tC, y=Math.max(0, y0-0.5*RULE.g*tC*tC);
    const vx=v0, vy=-RULE.g*tC;
    const last=trailPts[trailPts.length-1], cur={x,y};
    trailPts.push(cur); drawTrailSegment(last,cur);
    placeBallAt(x,y); updateVelocityVector(vx,vy);
    posNowEl.textContent=`${x.toFixed(2)} m, ${y.toFixed(2)} m`;
    tValEl.textContent=tC.toFixed(2)+' s';
    xLandVal.textContent=xLand.toFixed(2)+' m';
    if(t < tFlight - 1e-3) requestAnimationFrame(step);
    else{
      placeBallAt(xLand,0); updateVelocityVector(v0,-RULE.g*tFlight);
      const last2 = trailPts[trailPts.length-1]; const endp={x:xLand,y:0};
      trailPts.push(endp); drawTrailSegment(last2,endp);
      evaluateAndProceedServerLike(v0, ticket);
    }
  }
  requestAnimationFrame(step);
}



/* 進行 */
function nextRound(){ 
  if (finished) { showToast('5投が終わりました。提出かリセットをしてください'); return; }
  if(currentRound < RULE.rounds){ currentRound += 1; } 
  setupRound(); }
function resetGame(){
  currentRound=1; score=0; lastGainedPoints=0; scoreHUD.textContent='0点';
  finished = false;
  newAttempt();
  retryBtn.style.display='inline-block'; resetBtn.style.display='none';
  submitBox.style.display='none'; submitBtn.disabled=false; studentIdInput.disabled=false; studentNameInput.disabled=false;
  studentIdInput.value=''; studentNameInput.value='';
  tickets.length = 0;      // 使っていない配列なら削除可
  locked=false; running=true;
  setupRound(); requestAnimationFrame(rouletteLoop);
  window.scrollTo({top:0, behavior:'instant'});
}

/* クリック：tClick だけ送る（v0はサーバ計算） */
lockBtn.addEventListener('click', async ()=>{
  if (finished) { showToast('5投が終わりました。提出かリセットをしてください'); return; }
  if (locked) return;
  if (ticketsByRound.has(currentRound)) { showToast('このラウンドは記録済みです'); return; }

  locked = true;
  running = false;
  lockBtn.disabled = true;
  retryBtn.disabled = true;

  try{
    const tClickLocal = Date.now();
    const j = await lockClose(currentRound, tClickLocal);

    // ★ここは1回だけ！
    const v0 = Number(j.v0);

const received = { ticket: { ...j.ticket, attemptId }, sig: j.sig, v0 };
 ticketsByRound.set(currentRound, received);
 currentTicket = j.ticket; // ← これをセット
 // 投射アニメーション
 animateThrow(v0, currentTicket); // もしくは animateThrow(v0, j.ticket)

  }catch(e){
    console.error(e);
    showToast('サーバに接続できません（ロック失敗）');
    locked = false;
    running = true;
    lockBtn.disabled = false;
    retryBtn.disabled = true;
    requestAnimationFrame(rouletteLoop);
  }
});
  
retryBtn.addEventListener('click', nextRound);
resetBtn.addEventListener('click', resetGame);
document.addEventListener('keydown',(e)=>{
  const ae=document.activeElement; const tag=ae?.tagName;
  if(tag==='INPUT'||tag==='TEXTAREA'||ae?.isContentEditable) return;
  if(e.repeat) return;
  const k=(e.key||'').toLowerCase();
  if(k==='l'||e.code==='KeyL'){ if(!lockBtn.disabled && !locked){ lockBtn.click(); e.preventDefault(); } return; }
  if(k==='n'||e.code==='KeyN'){ const hidden=retryBtn.style.display==='none'; if(!retryBtn.disabled && !hidden){ retryBtn.click(); e.preventDefault(); } }
});




function serverLikeTotal(tickets){
  // 定数（ローカル）
  const G = 9.8, VMIN = 0, VMAX = 6;
  const PERIOD_MS = (Number(RULE.cycleSec) || 4) * 1000; // 周期4秒
  const SCORE_BANDS = [
    {lt:0.01,pts:5},{lt:0.03,pts:4},{lt:0.10,pts:3},{lt:0.20,pts:2},{lt:0.30,pts:1}
  ];

  let total = 0, details = [];
  for (const t0 of tickets){
    // 型正規化
    const tClickAdj = Number(t0.tClickAdj ?? NaN);
    const y0 = Number(t0.y0 ?? NaN);
    const xTarget = Number(t0.xTarget ?? NaN);
    const round = Number(t0.round ?? NaN);

    // v0 は「サーバ返却を最優先」。なければ周期から復元
    let v0 = Number(t0.v0);
    if (!Number.isFinite(v0)) {
      const n = ((tClickAdj / PERIOD_MS) % 1 + 1) % 1; // 0..1
      v0 = VMIN + n * (VMAX - VMIN);
    }

    if (!Number.isFinite(y0) || !Number.isFinite(xTarget) || xTarget <= 0) {
      details.push({ round, y0, xTarget, v0, tFlight:NaN, xLand:NaN, errPct:Infinity, gained:0 });
      continue;
    }

    const tFlight = Math.sqrt((2*y0)/G);
    const xLand   = v0 * tFlight;
    const errPct  = Math.abs(xLand - xTarget) / xTarget;

    let gained = 0;
    for (const b of SCORE_BANDS){ if (errPct < b.lt){ gained = b.pts; break; } }
    total += gained;

    details.push({
      round, y0, xTarget,
      v0: +v0.toFixed(6),
      tFlight: +tFlight.toFixed(6),
      xLand: +xLand.toFixed(6),
      errPct: +errPct.toFixed(6),
      gained
    });
  }
  return { total, details };
}


 function serverLikeSingle(t){
  const G = 9.8, VMIN = 0, VMAX = 6;
  const PERIOD_MS = (Number(RULE.cycleSec) || 4) * 1000;
  const SCORE_BANDS = [
    {lt:0.01,pts:5},{lt:0.03,pts:4},{lt:0.10,pts:3},{lt:0.20,pts:2},{lt:0.30,pts:1}
  ];

  const round    = Number(t.round ?? NaN);
  const y0       = Number(t.y0 ?? NaN);
  const xTarget  = Number(t.xTarget ?? NaN);
  const tClickAdj= Number(t.tClickAdj ?? NaN);

  let v0 = Number(t.v0);
  if (!Number.isFinite(v0)) {
    const n = ((tClickAdj / PERIOD_MS) % 1 + 1) % 1;
    v0 = VMIN + n*(VMAX - VMIN);
  }

  const tFlight = Math.sqrt((2*y0)/G);
  const xLand   = v0 * tFlight;
  const errPct  = Math.abs(xLand - xTarget) / xTarget;

  let gained = 0;
  for (const b of SCORE_BANDS){ if (errPct < b.lt){ gained = b.pts; break; } }

  return { round, y0, xTarget, v0, tFlight, xLand, errPct, gained };
}



// サーバ式で採点 → UI反映・加点・終了処理
function evaluateAndProceedServerLike(v0FromServer, ticket){
   const y0 = Number(ticket.y0);
   const xTarget = Number(ticket.xTarget);
   const tFlight = Math.sqrt((2*y0)/RULE.g);
   const xLand   = v0FromServer * tFlight;
   const errPct  = Math.abs(xLand - xTarget) / xTarget;
   const r = { v0: v0FromServer, tFlight, xLand, errPct,
              gained: (errPct<0.01?5:errPct<0.03?4:errPct<0.10?3:errPct<0.20?2:errPct<0.30?1:0) };
   

  // デバッグ（各ラウンドの詳細を見たいとき用）
  console.log('[round result(server-like)]', {
    round: ticket.round,
    y0: ticket.y0,
    xTarget: ticket.xTarget,
    tClickAdj: ticket.tClickAdj,
    v0: r.v0,
    tFlight: r.tFlight,
    xLand: r.xLand,
    errPct: r.errPct,
    gained: r.gained
  });

  
  // 表示用バンド（UIの表示テキスト／色）
  const bandsUI = [
    { lt: 0.01, pts: 5, label: 'PERFECT!!!!', cls:'perfect',  decimals:2 },
    { lt: 0.03, pts: 4, label: 'Excellent!!!', cls:'excellent',decimals:1 },
    { lt: 0.10, pts: 3, label: 'great!!',      cls:'great',    decimals:1 },
    { lt: 0.20, pts: 2, label: 'good!',        cls:'good',     decimals:1 },
    { lt: 0.30, pts: 1, label: 'ok',           cls:'ok',       decimals:1 },
  ];
  let band = null;
  for (const b of bandsUI){ if (r.errPct < b.lt){ band = b; break; } }

  // UI反映・サウンド
  if (r.gained > 0 && band){
    score += r.gained;
    const pct = (r.errPct*100).toFixed(band.decimals);
    resultTextHUD.innerHTML = `<span class="${band.cls}">${band.label}（誤差 ${pct}% / +${r.gained}点）</span>`;
    (r.gained>=3 ? greatSound : goodSound)();
  }else{
    resultTextHUD.innerHTML = `<span class="bad">miss…（誤差 ${(r.errPct*100).toFixed(1)}%）</span>`;
    wrongSound();
  }
  scoreHUD.textContent = String(score) + '点';

  // 次アクション
  lastGainedPoints = r.gained;
  lockBtn.disabled = true;
  retryBtn.disabled = false;

  // 最終ラウンド処理
  if (currentRound >= RULE.rounds){
    const finalMsg = (score >= 10) ? '課題クリア！' : '10点目指してもう1度頑張ろう！';
    resultTextHUD.innerHTML =
      `<div>5回目の得点：<strong>+${lastGainedPoints}点</strong></div>` +
      `<div>全${RULE.rounds}回の合計スコア：<strong>${score}点</strong></div>`;
    challengeTextHUD.textContent = finalMsg;
    retryBtn.style.display='none';
  resetBtn.style.display='inline-block';
  finished = true;         // ← 終了フラグ
  locked = true;           // 念のため
  running = false;         // ルーレットも止める
    
    if (score >= 10) { showSubmitBox(); }
    else { submitBox.style.display='none'; showToast('今回はスコアが10点未満のため提出できません'); }
  }
}

  



// ここで check.total が 10 未満なら、サーバ判定どおり（=フロント表示の14点とズレている原因を details で特定）。
// 10 以上ならサーバ返却とズレているので、その旨を console に出す。


  

  

/* 提出：サンプル（必要なら close 返却の ticket を配列で貯めて送る実装に変更可） */
function showSubmitBox(){ submitBox.style.display='block'; studentIdInput.focus(); }


  async function submitResult(){
    submitBtn.disabled = true;
  // 1) 送る前に Map → 配列化（round 昇順）＆型ゆらぎを数値に正規化

const all = Array.from(ticketsByRound.values())
   .sort((a,b) => Number(a.ticket.round) - Number(b.ticket.round));

    

  // 2) 基本チェック
  console.log('[submit] ticketsByRound.size =', ticketsByRound.size, ' / RULE.rounds =', RULE.rounds);
  console.table(all);
 if (all.length !== RULE.rounds) {
   showToast(`提出データが不足しています（${all.length}/${RULE.rounds}）`);

    
    return;
  }
  // round が 1..RULE.rounds の連番か軽く検証
const roundsOK = all.every((t,i)=> Number(t.ticket.round) === i+1);
    const attemptOK = all.every(t => t.ticket.attemptId === attemptId);


  if (!roundsOK || !attemptOK) {
  showToast('提出データが「直近の5投」だけになっていません（リセット→やり直し推奨）');
    return;
  }

  // 3) “サーバ式”でローカル再計算（提出データは触らない！）
let check;
try{
 const normalized = all.map(x => ({
   round:     Number(x.ticket.round),
   tClickAdj: Number(x.ticket.tClickAdj),
   y0:        Number(x.ticket.y0),
   xTarget:   Number(x.ticket.xTarget),
   v0:        Number(x.v0),            // サーバ返却 v0 を優先（無ければ復元）
 }));
    check = serverLikeTotal(normalized);
  console.log('[submit] serverLikeTotal.total =', check.total);
  console.table(check.details);
  score = check.total;
  scoreHUD.textContent = score + '点';
}catch(e){
  console.error('[submit] local serverLike scoring failed', e);
  showToast('内部エラー（ローカル採点）。提出は継続します。');
}

 

  // 4) 入力チェック
  const studentId = studentIdInput.value.trim();
  const studentName = studentNameInput.value.trim();
  if(!/^\d{4}$/.test(studentId) || !studentName){
    showToast('4桁番号(半角)と氏名を入力してください');
    return;
  }
  if(!session.sessionId || !session.nonce){
    showToast('セッション取得に失敗。ページ再読み込みを試してください');
    return;
  }

    // 4.5) 提出直前のセッション再取得（サーバ側が更新されていないか確認）
 try {
   await fetchSession(); // ここで server 側の最新 ruleVersion / ticketSig を取得
 } catch (e) {
   console.warn('[submit] re-fetchSession failed', e);
   showToast('セッション再取得に失敗しました。ページを再読み込みしてください');
   submitBtn.disabled = false;
   return;
 }

 // サーバ最新版と「ラウンドのチケット内 ruleVersion」が揃っているか再チェック
 const allRuleOK = all.every(x => String(x.ticket?.ruleVersion) === String(session.ruleVersion));
 if (!allRuleOK) {
   console.warn('[submit] ruleVersion mismatch just before submit',
     { sessionRule: session.ruleVersion, rounds: all.map(a => a.ticket?.ruleVersion) });
   showToast('サーバのバージョンが更新されました。ページを再読み込みして最初から実行してください');
   submitBtn.disabled = false;
   return;
 }

    



    
  // 5) 送信（チケットは正規化済み allTickets をそのまま JSON 化）
const payloadTickets = all.map(x => ({
  ...x.ticket,          // round / tClickAdj / y0 / xTarget / ruleVersion / (サーバが入れてるなら v0 も)
  v0: x.v0,             // もし提出に v0 も含める運用なら残す（サーバで無視するなら削ってOK）
  sig: x.sig            // サーバからの署名
}));

// 可視化（table + JSON）
console.groupCollapsed('[will-submit] tickets[]');
console.table(payloadTickets.map(t => ({
  round: t.round, y0: t.y0, xTarget: t.xTarget,
  tClickAdj: t.tClickAdj, v0: t.v0,
  sig_head: String(t.sig||'').slice(0,12)+'…'
})));
console.log('payloadTickets (JSON):\n', JSON.stringify(payloadTickets, null, 2));

// “送る配列”でローカル再採点して最終確認（任意）
try{
  const recap = serverLikeTotal(payloadTickets);
  console.log('[will-submit] local total from payloadTickets =', recap.total);
  console.table(recap.details);
}catch(e){
  console.warn('[will-submit] local scoring from payloadTickets failed', e);
}
console.groupEnd();
    
  try{
    const body = new URLSearchParams({
      studentId,
      studentName,
      sessionId: String(session.sessionId),
      nonce: String(session.nonce),
      ticketSig: String(session.ticketSig || ''), 
      ruleVersion: String(session.ruleVersion || RULE.version),
      t0Ms: String(session.t0Ms),                               
      phiSec: String(session.phiSec), 
      clientToken: String(clientToken || ''),
      tickets: JSON.stringify(payloadTickets)
    });
    

    // ── ワンライナー診断（送る中身の目視用） ──
    console.log('[submit body]');
console.table(Array.from(body.entries()));
    console.log('[clientToken sending]', clientToken);

const res = await fetch(GAS_SUBMIT_URL, {
     method:'POST',
     body,
     credentials:'omit',
     headers:{ 'Content-Type':'application/x-www-form-urlencoded;charset=UTF-8',
               'Accept':'application/json' }
   });
    
    const json = await res.json().catch(()=> ({}));

    // ★ここでサーバ返答を丸ごと表示
console.log('[submit response]', json);

    if(json && json.ok){
      showToast('送信しました！');
      submitBtn.disabled = true; studentIdInput.disabled = true; studentNameInput.disabled = true;
      setTimeout(loadLeaderboard, 4000);
    }else{
      const msg = ({
        'INVALID_STUDENT_ID':'学籍番号が正しくありません',
        'EMPTY_NAME':'氏名を入力してください',
        'INVALID_TICKETS':'提出データが不正です',
        'RULE_VERSION_MISMATCH':'バージョンが異なります（再読み込みしてください）',
        'BAD_TICKET':'改ざん検出（再読み込みしてやり直してください）',
        'SCORE_BELOW_THRESHOLD':'10点未満は提出できません',
        'SESSION_EXPIRED':'セッション期限切れ（再読み込みしてください）',
      })[json.error] || '送信に失敗しました…';
      showToast(msg);
      submitBtn.disabled = false; // 失敗時は再トライ可
    }
  }catch(e){
    console.error(e);
    showToast('送信に失敗しました…');
    submitBtn.disabled = false;
  }
}


  
if(submitBtn){ submitBtn.addEventListener('click', submitResult); }

/* ランキング（元のまま） */
async function loadLeaderboard(){ /* 省略せずそのまま */ 
  const desktopBox = document.getElementById('leaderboard');
  const mobileBox  = document.getElementById('leaderboardMobile');
  if (!desktopBox && !mobileBox) return;
  try{
    if(!CSV_URL || /【/.test(CSV_URL)){
      const html='ランキングのCSV URLが未設定です。';
      if(desktopBox) desktopBox.textContent=html;
      if(mobileBox)  mobileBox.textContent=html;
      return;
    }
    const url = CSV_URL + (CSV_URL.includes('?') ? '&':'?') + 'cb=' + Date.now();
    const res = await fetch(url, { credentials:'omit', cache:'no-store' });
    const text = await res.text();
    const { cols, rows } = parseCSV(text);
    renderFromRows(cols, rows);
  }catch(e){ console.error(e); const msg='ランキングを読み込めませんでした…'; if(desktopBox) desktopBox.textContent=msg; if(mobileBox) mobileBox.textContent=msg; }
  function renderFromRows(cols, rows){
    const idx={ timestamp:findIndex(cols,/time|タイムスタンプ|timestamp/i,0), studentId:findIndex(cols,/番号|学籍|id/i,1), studentName:findIndex(cols,/氏名|名前|name/i,2), totalScore:findIndex(cols,/score|スコア|合計|点/i,3) };
    let recs=rows.map(r=>({ timestamp:String(r[idx.timestamp]??''), id:String(r[idx.studentId]??'').trim(), name:String(r[idx.studentName]??'').trim(), score:Number(String(r[idx.totalScore]??'').replace(/[^\d.-]/g,'')) }));
    recs=recs.filter(x=>Number.isFinite(x.score)&&x.score>=10);
    recs=bestByKey(recs,x=>x.id||x.name);
    recs.sort((a,b)=>b.score-a.score || (new Date(b.timestamp)-new Date(a.timestamp)));
    recs=recs.slice(0,20);
    const html=renderTableHTML(recs);
    if(desktopBox) desktopBox.innerHTML=html; if(mobileBox) mobileBox.innerHTML=html;
  }
}
function parseCSV(text){ const rows=[]; let cur=[],field='',inQ=false; for(let i=0;i<text.length;i++){ const ch=text[i],next=text[i+1]; if(inQ){ if(ch==='"'&&next==='"'){field+='"'; i++;} else if(ch==='"'){inQ=false;} else {field+=ch;} } else { if(ch==='"'){inQ=true;} else if(ch===','){cur.push(field); field='';} else if(ch==='\n'){cur.push(field); rows.push(cur); cur=[]; field='';} else if(ch==='\r'){} else {field+=ch;} } } if(field.length||cur.length){cur.push(field); rows.push(cur);} const cols=rows.shift()||[]; return{cols,rows}; }
function findIndex(arr,regex,fallback=-1){ const i=arr.findIndex(h=>regex.test(String(h))); return i>=0?i:fallback; }
function bestByKey(list,keyFn){ const best=new Map(); for(const r of list){ const k=keyFn(r); if(!k) continue; const cur=best.get(k); if(!cur||r.score>cur.score) best.set(k,r); } return Array.from(best.values()); }
function renderTableHTML(items){
  if(!items.length) return 'まだランキングはありません。';
  const left=items.slice(0,10), right=items.slice(10,20);
  const rows=Array.from({length:10},(_,i)=>({L:left[i]||{name:'',id:'',score:''},R:right[i]||{name:'',id:'',score:''}}));
  return `
  <table style="width:100%; border-collapse:collapse; table-layout:fixed; font-size:14px; margin-bottom:8px">
    <colgroup>
      <col style="width:7%"><col style="width:33%"><col style="width:12%"><col style="width:18%">
      <col style="width:4%">
      <col style="width:7%"><col style="width:33%"><col style="width:12%"><col style="width:18%">
    </colgroup>
    <thead>
      <tr>
        <th style="text-align:center; padding:6px 8px; border-bottom:1px solid rgba(255,255,255,.12)">位</th>
        <th style="text-align:left;   padding:6px 8px; border-bottom:1px solid rgba(255,255,255,.12)">氏名</th>
        <th style="text-align:center; padding:6px 8px; border-bottom:1px solid rgba(255,255,255,.12)">番号</th>
        <th style="text-align:right;  padding:6px 8px; border-bottom:1px solid rgba(255,255,255,.12)">スコア</th>
        <th></th>
        <th style="text-align:center; padding:6px 8px; border-bottom:1px solid rgba(255,255,255,.12)">位</th>
        <th style="text-align:left;   padding:6px 8px; border-bottom:1px solid rgba(255,255,255,.12)">氏名</th>
        <th style="text-align:center; padding:6px 8px; border-bottom:1px solid rgba(255,255,255,.12)">番号</th>
        <th style="text-align:right;  padding:6px 8px; border-bottom:1px solid rgba(255,255,255,.12)">スコア</th>
      </tr>
    </thead>
    <tbody>
      ${rows.map((r,i)=>`
        <tr>
          <td style="text-align:center; font-weight:700; font-variant-numeric: tabular-nums">${i+1}</td>
          <td style="overflow:hidden; text-overflow:ellipsis; white-space:nowrap">${escapeHTML(r.L.name || '—')}</td>
          <td style="text-align:center; font-variant-numeric: tabular-nums">${escapeHTML(r.L.id || '—')}</td>
          <td style="text-align:right;  font-variant-numeric: tabular-nums">${r.L.score ?? ''}</td>
          <td></td>
          <td style="text-align:center; font-weight:700; font-variant-numeric: tabular-nums">${i+11}</td>
          <td style="overflow:hidden; text-overflow:ellipsis; white-space:nowrap">${escapeHTML(r.R.name || '—')}</td>
          <td style="text-align:center; font-variant-numeric: tabular-nums">${escapeHTML(r.R.id || '—')}</td>
          <td style="text-align:right;  font-variant-numeric: tabular-nums">${r.R.score ?? ''}</td>
        </tr>`).join('')}
    </tbody>
  </table>`;
}
function escapeHTML(s){ return String(s).replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

/* リサイズ対応 */
function handleResize(){
  baselineTop=null; fitSceneToViewport(); fitScales(); layoutSubground(); renderGrid(); layoutBuilding(curY || y0);
  resizeTrailCanvas(); placeBallAt(curX, curY || y0);
  updateVelocityVector(visualV, 0);
}
window.addEventListener('resize', handleResize);
window.addEventListener('orientationchange', ()=>setTimeout(handleResize,200));
if(window.visualViewport){ window.visualViewport.addEventListener('resize', ()=>setTimeout(handleResize,50)); }

/* 初期化 */
(async function init(){
  await fetchSession();              // サーバ時刻合わせ
  requestAnimationFrame(rouletteLoop); // ルーレット常時描画
  await setupRound();                // 第1ラウンド
  loadLeaderboard();
  setInterval(loadLeaderboard, 60000);
})();
})();
</script>
</body>
</html>
